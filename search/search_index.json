{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Schemasheets Create a data dictionary / schema for your data using simple spreadsheets - no coding required. About Author your schema as a google sheet or excel spreadsheet Generate schemas : LinkML SHACL and ShEx JSON-Schema SQL DDL OWL Get tooling for free: Data validators Python bindings Create a website for your schema Examples See the test google sheets for examples See also the examples folder which has an end-to-end example Audience This tool is aimed at data modelers, curators, wrangers, and creators of standards and datamodels. It is aimed at people who prefer to develop these standards using spreadsheet tools over more developer-centric tooling. Using schemasheets you can develop your standard using google sheets, excel or any other table-editing tool. A variety of tooling is constructed automatically from this, no coding required. Future Developments We hope to soon harden parts of the toolchain, and also add more features that make it easier for non-technical people to use, include: Web based tooling for managing schemas Integration of existing LinkML tools, such as automated schema inference and mapping How to read this documentation Use the section headings at the top of this page to jump to any section, or Previous/Next to follow in a linear order.","title":"About"},{"location":"#schemasheets","text":"Create a data dictionary / schema for your data using simple spreadsheets - no coding required.","title":"Schemasheets"},{"location":"#about","text":"Author your schema as a google sheet or excel spreadsheet Generate schemas : LinkML SHACL and ShEx JSON-Schema SQL DDL OWL Get tooling for free: Data validators Python bindings Create a website for your schema","title":"About"},{"location":"#examples","text":"See the test google sheets for examples See also the examples folder which has an end-to-end example","title":"Examples"},{"location":"#audience","text":"This tool is aimed at data modelers, curators, wrangers, and creators of standards and datamodels. It is aimed at people who prefer to develop these standards using spreadsheet tools over more developer-centric tooling. Using schemasheets you can develop your standard using google sheets, excel or any other table-editing tool. A variety of tooling is constructed automatically from this, no coding required.","title":"Audience"},{"location":"#future-developments","text":"We hope to soon harden parts of the toolchain, and also add more features that make it easier for non-technical people to use, include: Web based tooling for managing schemas Integration of existing LinkML tools, such as automated schema inference and mapping","title":"Future Developments"},{"location":"#how-to-read-this-documentation","text":"Use the section headings at the top of this page to jump to any section, or Previous/Next to follow in a linear order.","title":"How to read this documentation"},{"location":"faq/","text":"FAQ How can I get more help? The best way to get help is to ask on the github issue tracker Is there a specification? Schemasheets has its own specification: https://linkml.io/schemasheets/specification/ This is separate from the main LinkML specification Where do I ask questions about LinkML? See the LinkML FAQ Why would I want to use schemasheets? Schemasheets are designed for easy, efficient and rapid collection of metadata elements and column headers for wide-table data Lists of column headers/metadata elements and their associated information are easily managed Enumerations can be explicitly provided - and mapped to ontologies A flexible approach allows for schemas to be broken out over different sheets in different ways When should I not use schemasheets? Schemasheets works best for wide-table data, or \"tidy\" data, in which any individual observation or data point can have many variables or metadata elements associated with them If your data follows higher \"normal forms\" or is narrow then you may be better authoring directly in LinkML yaml. Schemasheets also works best when you want to involve non-technical people is modeling decisions and in definitions of metadata elements. Most domain experts are comfortable looking at lists of things in spreadsheets. If your modeling team is quite technical, we recommend authoring your schema directly in LinkML YAML Can I use schemasheets to make JSON-Schema? Why, yes you can! You can chain together sheets2linkml and gen-json-schema - or use sheets2project Note that of course if your JSON is highly nested, then it may not make sense to manage the schema in a spreadsheet-like form. Schemasheets works best for \"wide-table\" data Can I use schemasheets to make SHACL Shape Schemas? Indeed, you certainly can! You can chain together sheets2linkml and gen-shacl - or use sheets2project Note that of course if your RDF is highly relational, then it may not make sense to manage the schema in a spreadsheet-like form. Schemasheets works best for \"wide-table\" data Can I use schemasheets to make SQL DDL? I'm glad you asked, this is indeed possible You can chain together sheets2linkml and gen-sqlddl - or use sheets2project Can I make a nice looking website for my schema? Definitely! You can chain together sheets2linkml and gen-doc - or use sheets2project This will make a static site ready for publishing on GitHub!","title":"FAQ"},{"location":"faq/#faq","text":"","title":"FAQ"},{"location":"faq/#how-can-i-get-more-help","text":"The best way to get help is to ask on the github issue tracker","title":"How can I get more help?"},{"location":"faq/#is-there-a-specification","text":"Schemasheets has its own specification: https://linkml.io/schemasheets/specification/ This is separate from the main LinkML specification","title":"Is there a specification?"},{"location":"faq/#where-do-i-ask-questions-about-linkml","text":"See the LinkML FAQ","title":"Where do I ask questions about LinkML?"},{"location":"faq/#why-would-i-want-to-use-schemasheets","text":"Schemasheets are designed for easy, efficient and rapid collection of metadata elements and column headers for wide-table data Lists of column headers/metadata elements and their associated information are easily managed Enumerations can be explicitly provided - and mapped to ontologies A flexible approach allows for schemas to be broken out over different sheets in different ways","title":"Why would I want to use schemasheets?"},{"location":"faq/#when-should-i-not-use-schemasheets","text":"Schemasheets works best for wide-table data, or \"tidy\" data, in which any individual observation or data point can have many variables or metadata elements associated with them If your data follows higher \"normal forms\" or is narrow then you may be better authoring directly in LinkML yaml. Schemasheets also works best when you want to involve non-technical people is modeling decisions and in definitions of metadata elements. Most domain experts are comfortable looking at lists of things in spreadsheets. If your modeling team is quite technical, we recommend authoring your schema directly in LinkML YAML","title":"When should I not use schemasheets?"},{"location":"faq/#can-i-use-schemasheets-to-make-json-schema","text":"Why, yes you can! You can chain together sheets2linkml and gen-json-schema - or use sheets2project Note that of course if your JSON is highly nested, then it may not make sense to manage the schema in a spreadsheet-like form. Schemasheets works best for \"wide-table\" data","title":"Can I use schemasheets to make JSON-Schema?"},{"location":"faq/#can-i-use-schemasheets-to-make-shacl-shape-schemas","text":"Indeed, you certainly can! You can chain together sheets2linkml and gen-shacl - or use sheets2project Note that of course if your RDF is highly relational, then it may not make sense to manage the schema in a spreadsheet-like form. Schemasheets works best for \"wide-table\" data","title":"Can I use schemasheets to make SHACL Shape Schemas?"},{"location":"faq/#can-i-use-schemasheets-to-make-sql-ddl","text":"I'm glad you asked, this is indeed possible You can chain together sheets2linkml and gen-sqlddl - or use sheets2project","title":"Can I use schemasheets to make SQL DDL?"},{"location":"faq/#can-i-make-a-nice-looking-website-for-my-schema","text":"Definitely! You can chain together sheets2linkml and gen-doc - or use sheets2project This will make a static site ready for publishing on GitHub!","title":"Can I make a nice looking website for my schema?"},{"location":"install/","text":"Installation Requirements Python 3.7 or higher is required. Install Schemasheets Install in the standard way from PyPi: pip install schemasheets You can test this works: sheets2linkml --help Usage: sheets2linkml [OPTIONS] [TSV_FILES]... Convert schemasheets to a LinkML schema Example: sheets2linkml my_schema/*tsv --output my_schema.yaml If your sheets are stored as google sheets, then you can pass in --gsheet- id to give the base sheet. In this case arguments should be the names of individual tabs Example: sheets2linkml --gsheet-id 1wVoaiFg47aT9YWNeRfTZ8tYHN8s8PAuDx5i2HUcDpvQ personinfo types -o my_schema.yaml Options: -o, --output FILENAME output file -n, --name TEXT name of the schema --unique-slots / --no-unique-slots All slots are treated as unique and top level and do not belong to the specified class [default: False] --repair / --no-repair Auto-repair schema [default: True] --gsheet-id TEXT Google sheets ID. If this is specified then the arguments MUST be sheet names -v, --verbose --help Show this message and exit. Docker If you have Docker installed you can run schemasheets via Docker like this: docker run -v $PWD:/work -w /work -ti linkml/schemasheets sheets2linkml --help","title":"Installation"},{"location":"install/#installation","text":"","title":"Installation"},{"location":"install/#requirements","text":"Python 3.7 or higher is required.","title":"Requirements"},{"location":"install/#install-schemasheets","text":"Install in the standard way from PyPi: pip install schemasheets You can test this works: sheets2linkml --help Usage: sheets2linkml [OPTIONS] [TSV_FILES]... Convert schemasheets to a LinkML schema Example: sheets2linkml my_schema/*tsv --output my_schema.yaml If your sheets are stored as google sheets, then you can pass in --gsheet- id to give the base sheet. In this case arguments should be the names of individual tabs Example: sheets2linkml --gsheet-id 1wVoaiFg47aT9YWNeRfTZ8tYHN8s8PAuDx5i2HUcDpvQ personinfo types -o my_schema.yaml Options: -o, --output FILENAME output file -n, --name TEXT name of the schema --unique-slots / --no-unique-slots All slots are treated as unique and top level and do not belong to the specified class [default: False] --repair / --no-repair Auto-repair schema [default: True] --gsheet-id TEXT Google sheets ID. If this is specified then the arguments MUST be sheet names -v, --verbose --help Show this message and exit.","title":"Install Schemasheets"},{"location":"install/#docker","text":"If you have Docker installed you can run schemasheets via Docker like this: docker run -v $PWD:/work -w /work -ti linkml/schemasheets sheets2linkml --help","title":"Docker"},{"location":"specification/","text":"Specification (in progress) The following is an outline. Please refer to the above examples for elucidation. Sheet Structure A sheet is a collection of one or more tables A table is a named list of rows A row is an array of values (cells) A value is a UTF-8 string Note : we follow google terminology here, with a sheet being the encompassing structure, and each containing tabs Any formatting information (color, font, etc) is ignored Any individual table is organized into Exactly one header row. This MUST be first. Zero or more column configuration rows. These MUST come after the header row, and must start with > Zero or more element rows Header line The first row in a table is a header row. Each element of this row is called a column Each column must be non-null and unique There is always exactly one header row The header row must be first Each column must be unique The header row provides an index into subsequent rows In future, grouping columns may be possible. Column Configurations Any subsequent rows where the first value start with a > character are column configurations A column configuration can be split over multiple lines. Each such subsequent line must start with > The > marks to delimit column configurations, and is subsequently ignored for parsing Each line must be a valid yaml string note that a single token is valid yaml for that token The first config line must include a descriptor Subsequent lines are settings for that descriptor A descriptor can be one of: Any LinkML metamodel slot (e.g. description, comments, range, required, recommended, multivalued) The keyword cardinality . See Cardinality enum in datamodel An element metatype (one of: schema, prefix, class, enum, slot, type, subset, permissible_value) A YAML object whose key is a descriptor and with values representing settings Setting can be taken from the schemasheets datamodel vmap provides a value mapping used to translate column values. E.g. a custom \"yes\" or \"no\" to \"true\" or \"false\" curie_prefix auto-prefixes the value in the cell with a curie prefix inner_key indicates that the column represents a complex/nested object, and the cell value populates that key Element Rows Remaining rows are elements of your schema Each element gets its own row A row must represent a unique element, which may be a: class (record, table) field (column) slot usage (a field in the context of a class) enumeration permissible value schema prefix type subset If a metatype descriptor is used: the type of the row is indicated by the metatype value (one of: class, slot, enum, type, schema) a name field must be present, this indicates the name of the element If a metatype descriptor is not used: some combination of class, slot, enum, permissible value schema, type are used to determine the row type plus the name if both class and slot are populated the row is interpreted as slot_usage (i.e a field in the context of a class) if only class is populated the row is a class element with name determined by the value of the class column if only slot is populated the row is a slot element with name determined by the value of the slot column if only type is populated the row is a type element with name determined by the value of the type column if only enum is populated the row is a enum element with name determined by the value of the enum column if both enum and permissible_value are populated the row is a permissible value element for that enum permissible_value must not be populated without enum being populated if only schema is populated the row is a schema element with name determined by the value of the schema column schema column may be populated in conjunction with any of the combination above to place the element in a schema all other combinations are forbidden All other columns are interpreted according to the column configuration for that column the column configuration includes curie_prefix then the value is prefixed with this value if the column configuration specifies a vmap this is used to map the provided values a column that is mapped to example automatically maps to example.value All sheets/TSVs are combined together into a single LinkML schema as YAML This LinkML schema can be translated to other formats as per the LinkML generators","title":"Specification (in progress)"},{"location":"specification/#specification-in-progress","text":"The following is an outline. Please refer to the above examples for elucidation.","title":"Specification (in progress)"},{"location":"specification/#sheet-structure","text":"A sheet is a collection of one or more tables A table is a named list of rows A row is an array of values (cells) A value is a UTF-8 string Note : we follow google terminology here, with a sheet being the encompassing structure, and each containing tabs Any formatting information (color, font, etc) is ignored Any individual table is organized into Exactly one header row. This MUST be first. Zero or more column configuration rows. These MUST come after the header row, and must start with > Zero or more element rows","title":"Sheet Structure"},{"location":"specification/#header-line","text":"The first row in a table is a header row. Each element of this row is called a column Each column must be non-null and unique There is always exactly one header row The header row must be first Each column must be unique The header row provides an index into subsequent rows In future, grouping columns may be possible.","title":"Header line"},{"location":"specification/#column-configurations","text":"Any subsequent rows where the first value start with a > character are column configurations A column configuration can be split over multiple lines. Each such subsequent line must start with > The > marks to delimit column configurations, and is subsequently ignored for parsing Each line must be a valid yaml string note that a single token is valid yaml for that token The first config line must include a descriptor Subsequent lines are settings for that descriptor A descriptor can be one of: Any LinkML metamodel slot (e.g. description, comments, range, required, recommended, multivalued) The keyword cardinality . See Cardinality enum in datamodel An element metatype (one of: schema, prefix, class, enum, slot, type, subset, permissible_value) A YAML object whose key is a descriptor and with values representing settings Setting can be taken from the schemasheets datamodel vmap provides a value mapping used to translate column values. E.g. a custom \"yes\" or \"no\" to \"true\" or \"false\" curie_prefix auto-prefixes the value in the cell with a curie prefix inner_key indicates that the column represents a complex/nested object, and the cell value populates that key","title":"Column Configurations"},{"location":"specification/#element-rows","text":"Remaining rows are elements of your schema Each element gets its own row A row must represent a unique element, which may be a: class (record, table) field (column) slot usage (a field in the context of a class) enumeration permissible value schema prefix type subset If a metatype descriptor is used: the type of the row is indicated by the metatype value (one of: class, slot, enum, type, schema) a name field must be present, this indicates the name of the element If a metatype descriptor is not used: some combination of class, slot, enum, permissible value schema, type are used to determine the row type plus the name if both class and slot are populated the row is interpreted as slot_usage (i.e a field in the context of a class) if only class is populated the row is a class element with name determined by the value of the class column if only slot is populated the row is a slot element with name determined by the value of the slot column if only type is populated the row is a type element with name determined by the value of the type column if only enum is populated the row is a enum element with name determined by the value of the enum column if both enum and permissible_value are populated the row is a permissible value element for that enum permissible_value must not be populated without enum being populated if only schema is populated the row is a schema element with name determined by the value of the schema column schema column may be populated in conjunction with any of the combination above to place the element in a schema all other combinations are forbidden All other columns are interpreted according to the column configuration for that column the column configuration includes curie_prefix then the value is prefixed with this value if the column configuration specifies a vmap this is used to map the provided values a column that is mapped to example automatically maps to example.value All sheets/TSVs are combined together into a single LinkML schema as YAML This LinkML schema can be translated to other formats as per the LinkML generators","title":"Element Rows"},{"location":"datamodel/","text":"Schemasheets-Mappings schema This is the datamodel for Schemasheets Configurations. Note that for most purposes you will likely not need to consult this. The key class is ColumnSettings Two controlled vocabularies are specified here: Cardinality - terms and abbreviations that can be used for cardinality Shortcuts - species column configurations Classes ColumnSettings - configuration for an individual column in a schema sheet. ValueMap - A key-value dictionary Mixins Slots \u279eapplies_to_class - if a value C is specified, then this column in the relevant row is interpreted as \u279eapplies_to_slot \u279ecurie_prefix - CURIE prefix prepended to column value. This may be used for column that describe mapping or class/slot uri properties of the element. For example, with column settings exact_mapping: {curie_prefix: dcterms} , an element row with column value contributor , the value will be transformed to dcterms:contributor \u279eprefix - string to be prefixed onto the column value \u279esuffix - string to be suffixied onto the column value \u279etag \u279etemplate - jinja templated format string \u279evmap - Specifies a mapping for column values map_key - key in the dictionary map_value - key in the dictionary Enums Cardinality - vocabulary for describing cardinality and applicability of slots or fields. Shortcuts - A vocabulary of permissible values as column descriptors that do not have an exact equivalent in the LinkML datamodel, Subsets Types Built in Bool Decimal ElementIdentifier NCName NodeIdentifier URI URIorCURIE XSDDate XSDDateTime XSDTime float int str Defined ElementReference ( str ) - A pointer to an element in a datamodel Boolean ( Bool ) - A binary (true or false) value Date ( XSDDate ) - a date (year, month and day) in an idealized calendar Datetime ( XSDDateTime ) - The combination of a date and time Decimal ( Decimal ) - A real number with arbitrary precision that conforms to the xsd:decimal specification Double ( float ) - A real number that conforms to the xsd:double specification Float ( float ) - A real number that conforms to the xsd:float specification Integer ( int ) - An integer Ncname ( NCName ) - Prefix part of CURIE Nodeidentifier ( NodeIdentifier ) - A URI, CURIE or BNODE that represents a node in a model. Objectidentifier ( ElementIdentifier ) - A URI or CURIE that represents an object in the model. String ( str ) - A character string Time ( XSDTime ) - A time object represents a (local) time of day, independent of any particular day Uri ( URI ) - a complete URI Uriorcurie ( URIorCURIE ) - a URI or a CURIE","title":"Schemasheets-Mappings schema"},{"location":"datamodel/#schemasheets-mappings-schema","text":"This is the datamodel for Schemasheets Configurations. Note that for most purposes you will likely not need to consult this. The key class is ColumnSettings Two controlled vocabularies are specified here: Cardinality - terms and abbreviations that can be used for cardinality Shortcuts - species column configurations","title":"Schemasheets-Mappings schema"},{"location":"datamodel/#classes","text":"ColumnSettings - configuration for an individual column in a schema sheet. ValueMap - A key-value dictionary","title":"Classes"},{"location":"datamodel/#mixins","text":"","title":"Mixins"},{"location":"datamodel/#slots","text":"\u279eapplies_to_class - if a value C is specified, then this column in the relevant row is interpreted as \u279eapplies_to_slot \u279ecurie_prefix - CURIE prefix prepended to column value. This may be used for column that describe mapping or class/slot uri properties of the element. For example, with column settings exact_mapping: {curie_prefix: dcterms} , an element row with column value contributor , the value will be transformed to dcterms:contributor \u279eprefix - string to be prefixed onto the column value \u279esuffix - string to be suffixied onto the column value \u279etag \u279etemplate - jinja templated format string \u279evmap - Specifies a mapping for column values map_key - key in the dictionary map_value - key in the dictionary","title":"Slots"},{"location":"datamodel/#enums","text":"Cardinality - vocabulary for describing cardinality and applicability of slots or fields. Shortcuts - A vocabulary of permissible values as column descriptors that do not have an exact equivalent in the LinkML datamodel,","title":"Enums"},{"location":"datamodel/#subsets","text":"","title":"Subsets"},{"location":"datamodel/#types","text":"","title":"Types"},{"location":"datamodel/#built-in","text":"Bool Decimal ElementIdentifier NCName NodeIdentifier URI URIorCURIE XSDDate XSDDateTime XSDTime float int str","title":"Built in"},{"location":"datamodel/#defined","text":"ElementReference ( str ) - A pointer to an element in a datamodel Boolean ( Bool ) - A binary (true or false) value Date ( XSDDate ) - a date (year, month and day) in an idealized calendar Datetime ( XSDDateTime ) - The combination of a date and time Decimal ( Decimal ) - A real number with arbitrary precision that conforms to the xsd:decimal specification Double ( float ) - A real number that conforms to the xsd:double specification Float ( float ) - A real number that conforms to the xsd:float specification Integer ( int ) - An integer Ncname ( NCName ) - Prefix part of CURIE Nodeidentifier ( NodeIdentifier ) - A URI, CURIE or BNODE that represents a node in a model. Objectidentifier ( ElementIdentifier ) - A URI or CURIE that represents an object in the model. String ( str ) - A character string Time ( XSDTime ) - A time object represents a (local) time of day, independent of any particular day Uri ( URI ) - a complete URI Uriorcurie ( URIorCURIE ) - a URI or a CURIE","title":"Defined"},{"location":"datamodel/Cardinality/","text":"Enum: Cardinality vocabulary for describing cardinality and applicability of slots or fields. Most elements in the dictionary have been mapped to a vocabulary called \"carvoc\", this has yet to be released. URI: schemasheets:Cardinality Other properties Aliases: multiplicity applicability Permissible Values Text Description Meaning Other Information mandatory At least one value MUST be provided carvoc:Mandatory {'annotations': {'maps_to': Annotation(tag='maps_to', value='required: true', extensions={}, annotations={}), 'min': Annotation(tag='min', value='1', extensions={}, annotations={}), 'opposite': Annotation(tag='opposite', value='optional', extensions={}, annotations={}), 'interpretation': Annotation(tag='interpretation', value='MUST', extensions={}, annotations={}), 'aliases': Annotation(tag='aliases', value='required', extensions={}, annotations={}), 'mixs_notation': Annotation(tag='mixs_notation', value='M', extensions={}, annotations={}), 'code': Annotation(tag='code', value='M', extensions={}, annotations={})}} optional A value MAY be provided carvoc:Optional {'annotations': {'maps_to': Annotation(tag='maps_to', value='required: false', extensions={}, annotations={}), 'min': Annotation(tag='min', value='0', extensions={}, annotations={}), 'opposite': Annotation(tag='opposite', value='mandatory', extensions={}, annotations={}), 'interpretation': Annotation(tag='interpretation', value='MAY', extensions={}, annotations={}), 'aliases': Annotation(tag='aliases', value='permissible', extensions={}, annotations={}), 'mixs_notation': Annotation(tag='mixs_notation', value='X', extensions={}, annotations={}), 'code': Annotation(tag='code', value='O', extensions={}, annotations={})}} recommended A value SHOULD be provided carvoc:Recommended {'annotations': {'maps_to': Annotation(tag='maps_to', value='{required: false, recommended: true}', extensions={}, annotations={}), 'min': Annotation(tag='min', value='0', extensions={}, annotations={}), 'opposite': Annotation(tag='opposite', value='not_recommended', extensions={}, annotations={}), 'interpretation': Annotation(tag='interpretation', value='SHOULD', extensions={}, annotations={}), 'aliases': Annotation(tag='aliases', value='strongly suggested', extensions={}, annotations={}), 'code': Annotation(tag='code', value='R', extensions={}, annotations={})}} not_recommended Values are permitted, but SHOULD NOT be filled in carvoc:NotRecommended {'annotations': {'maps_to': Annotation(tag='maps_to', value='{required: false, recommended: false, recommended_against: true}', extensions={}, annotations={}), 'min': Annotation(tag='min', value='0', extensions={}, annotations={}), 'opposite': Annotation(tag='opposite', value='recommended', extensions={}, annotations={}), 'interpretation': Annotation(tag='interpretation', value='SHOULD NOT', extensions={}, annotations={}), 'aliases': Annotation(tag='aliases', value='recommended against', extensions={}, annotations={}), 'code': Annotation(tag='code', value='-R', extensions={}, annotations={})}} applicable union of optional and mandatory carvoc:Applicable {'annotations': {'min': Annotation(tag='min', value='0', extensions={}, annotations={}), 'opposite': Annotation(tag='opposite', value='not_applicable', extensions={}, annotations={}), 'interpretation': Annotation(tag='interpretation', value='MAY', extensions={}, annotations={}), 'code': Annotation(tag='code', value='O/M', extensions={}, annotations={})}, 'comments': ['use of this descriptor is generally not recommendes as it is usually possible to commit']} not_applicable A value MUST NOT be provided carvoc:NotApplicable {'annotations': {'max': Annotation(tag='max', value='0', extensions={}, annotations={}), 'min': Annotation(tag='min', value='0', extensions={}, annotations={}), 'opposite': Annotation(tag='opposite', value='applicable', extensions={}, annotations={}), 'interpretation': Annotation(tag='interpretation', value='MUST NOT', extensions={}, annotations={}), 'mixs_notation': Annotation(tag='mixs_notation', value='-', extensions={}, annotations={}), 'code': Annotation(tag='code', value='-', extensions={}, annotations={})}, 'comments': ['a use case for this is for a field that has been deprecated', 'a use case for this is for annotating a field that is not applicable in a particular context']} zero_or_one not required, single-valued carvoc:ZeroToOne {'mixins': ['optional', 'single-valued'], 'annotations': {'maps_to': Annotation(tag='maps_to', value='{required: false, multivalued: false}', extensions={}, annotations={}), 'min': Annotation(tag='min', value='0', extensions={}, annotations={}), 'max': Annotation(tag='max', value='1', extensions={}, annotations={}), 'interpretation': Annotation(tag='interpretation', value='MUST, MAY', extensions={}, annotations={}), 'uml': Annotation(tag='uml', value='0..1', extensions={}, annotations={}), 'code': Annotation(tag='code', value='0..1', extensions={}, annotations={})}} exactly_one required, single-valued carvoc:ExactlyOne {'mixins': ['mandatory', 'single-valued'], 'annotations': {'maps_to': Annotation(tag='maps_to', value='{required: true, multivalued: false}', extensions={}, annotations={}), 'min': Annotation(tag='min', value='1', extensions={}, annotations={}), 'max': Annotation(tag='max', value='1', extensions={}, annotations={}), 'interpretation': Annotation(tag='interpretation', value='MUST', extensions={}, annotations={}), 'uml': Annotation(tag='uml', value='1..1', extensions={}, annotations={}), 'code': Annotation(tag='code', value='1..1', extensions={}, annotations={})}} zero_to_many not required, multi-valued carvoc:ZeroToMany {'mixins': ['optional', 'multi-valued'], 'annotations': {'maps_to': Annotation(tag='maps_to', value='{required: false, multivalued: true}', extensions={}, annotations={}), 'min': Annotation(tag='min', value='0', extensions={}, annotations={}), 'max': Annotation(tag='max', value=' ', extensions={}, annotations={}), 'interpretation': Annotation(tag='interpretation', value='MAY', extensions={}, annotations={}), 'uml': Annotation(tag='uml', value='0.. ', extensions={}, annotations={}), 'code': Annotation(tag='code', value='0..*', extensions={}, annotations={})}} one_to_many required, multi-valued carvoc:OneToMany {'mixins': ['mandatory', 'multi-valued'], 'annotations': {'maps_to': Annotation(tag='maps_to', value='{required: true, multivalued: true}', extensions={}, annotations={}), 'min': Annotation(tag='min', value='1', extensions={}, annotations={}), 'max': Annotation(tag='max', value=' ', extensions={}, annotations={}), 'interpretation': Annotation(tag='interpretation', value='MUST, MAY', extensions={}, annotations={}), 'uml': Annotation(tag='uml', value='1.. ', extensions={}, annotations={}), 'code': Annotation(tag='code', value='1..*', extensions={}, annotations={})}} single_valued not multi-valued carvoc:SingleValued {'annotations': {'maps_to': Annotation(tag='maps_to', value='multivalued: false', extensions={}, annotations={}), 'max': Annotation(tag='max', value='1', extensions={}, annotations={}), 'opposite': Annotation(tag='opposite', value='multi-valued', extensions={}, annotations={}), 'interpretation': Annotation(tag='interpretation', value='MAY', extensions={}, annotations={}), 'mixs_notation': Annotation(tag='mixs_notation', value='1', extensions={}, annotations={}), 'code': Annotation(tag='code', value='SV', extensions={}, annotations={})}} multi_valued multi-valued carvoc:MultiValued {'annotations': {'maps_to': Annotation(tag='maps_to', value='multivalued: true', extensions={}, annotations={}), 'max': Annotation(tag='max', value='*', extensions={}, annotations={}), 'opposite': Annotation(tag='opposite', value='single-valued', extensions={}, annotations={}), 'interpretation': Annotation(tag='interpretation', value='MAY', extensions={}, annotations={}), 'mixs_notation': Annotation(tag='mixs_notation', value='m', extensions={}, annotations={}), 'code': Annotation(tag='code', value='MV', extensions={}, annotations={})}} conditional A qualifier on cardinalities that indicates the interpretation is context-dependent carvoc:Conditional {'annotations': {'maps_to': Annotation(tag='maps_to', value='conditional: true', extensions={}, annotations={}), 'mixs_notation': Annotation(tag='mixs_notation', value='E', extensions={}, annotations={}), 'code': Annotation(tag='code', value='E+', extensions={}, annotations={})}} unconditional A qualifier on cardinalities that indicates the interpretation is context-independent carvoc:Unconditional {'annotations': {'maps_to': Annotation(tag='maps_to', value='conditional: false', extensions={}, annotations={}), 'code': Annotation(tag='code', value='E-', extensions={}, annotations={})}} conditional_mandatory carvoc:ConditionalMandatory {'mixins': ['mandatory', 'conditional'], 'annotations': {'maps_to': Annotation(tag='maps_to', value='{required: true, conditional: true}', extensions={}, annotations={}), 'mixs_notation': Annotation(tag='mixs_notation', value='C', extensions={}, annotations={}), 'code': Annotation(tag='code', value='EM', extensions={}, annotations={})}}","title":"Enum: Cardinality"},{"location":"datamodel/Cardinality/#enum-cardinality","text":"vocabulary for describing cardinality and applicability of slots or fields. Most elements in the dictionary have been mapped to a vocabulary called \"carvoc\", this has yet to be released. URI: schemasheets:Cardinality","title":"Enum: Cardinality"},{"location":"datamodel/Cardinality/#other-properties","text":"Aliases: multiplicity applicability","title":"Other properties"},{"location":"datamodel/Cardinality/#permissible-values","text":"Text Description Meaning Other Information mandatory At least one value MUST be provided carvoc:Mandatory {'annotations': {'maps_to': Annotation(tag='maps_to', value='required: true', extensions={}, annotations={}), 'min': Annotation(tag='min', value='1', extensions={}, annotations={}), 'opposite': Annotation(tag='opposite', value='optional', extensions={}, annotations={}), 'interpretation': Annotation(tag='interpretation', value='MUST', extensions={}, annotations={}), 'aliases': Annotation(tag='aliases', value='required', extensions={}, annotations={}), 'mixs_notation': Annotation(tag='mixs_notation', value='M', extensions={}, annotations={}), 'code': Annotation(tag='code', value='M', extensions={}, annotations={})}} optional A value MAY be provided carvoc:Optional {'annotations': {'maps_to': Annotation(tag='maps_to', value='required: false', extensions={}, annotations={}), 'min': Annotation(tag='min', value='0', extensions={}, annotations={}), 'opposite': Annotation(tag='opposite', value='mandatory', extensions={}, annotations={}), 'interpretation': Annotation(tag='interpretation', value='MAY', extensions={}, annotations={}), 'aliases': Annotation(tag='aliases', value='permissible', extensions={}, annotations={}), 'mixs_notation': Annotation(tag='mixs_notation', value='X', extensions={}, annotations={}), 'code': Annotation(tag='code', value='O', extensions={}, annotations={})}} recommended A value SHOULD be provided carvoc:Recommended {'annotations': {'maps_to': Annotation(tag='maps_to', value='{required: false, recommended: true}', extensions={}, annotations={}), 'min': Annotation(tag='min', value='0', extensions={}, annotations={}), 'opposite': Annotation(tag='opposite', value='not_recommended', extensions={}, annotations={}), 'interpretation': Annotation(tag='interpretation', value='SHOULD', extensions={}, annotations={}), 'aliases': Annotation(tag='aliases', value='strongly suggested', extensions={}, annotations={}), 'code': Annotation(tag='code', value='R', extensions={}, annotations={})}} not_recommended Values are permitted, but SHOULD NOT be filled in carvoc:NotRecommended {'annotations': {'maps_to': Annotation(tag='maps_to', value='{required: false, recommended: false, recommended_against: true}', extensions={}, annotations={}), 'min': Annotation(tag='min', value='0', extensions={}, annotations={}), 'opposite': Annotation(tag='opposite', value='recommended', extensions={}, annotations={}), 'interpretation': Annotation(tag='interpretation', value='SHOULD NOT', extensions={}, annotations={}), 'aliases': Annotation(tag='aliases', value='recommended against', extensions={}, annotations={}), 'code': Annotation(tag='code', value='-R', extensions={}, annotations={})}} applicable union of optional and mandatory carvoc:Applicable {'annotations': {'min': Annotation(tag='min', value='0', extensions={}, annotations={}), 'opposite': Annotation(tag='opposite', value='not_applicable', extensions={}, annotations={}), 'interpretation': Annotation(tag='interpretation', value='MAY', extensions={}, annotations={}), 'code': Annotation(tag='code', value='O/M', extensions={}, annotations={})}, 'comments': ['use of this descriptor is generally not recommendes as it is usually possible to commit']} not_applicable A value MUST NOT be provided carvoc:NotApplicable {'annotations': {'max': Annotation(tag='max', value='0', extensions={}, annotations={}), 'min': Annotation(tag='min', value='0', extensions={}, annotations={}), 'opposite': Annotation(tag='opposite', value='applicable', extensions={}, annotations={}), 'interpretation': Annotation(tag='interpretation', value='MUST NOT', extensions={}, annotations={}), 'mixs_notation': Annotation(tag='mixs_notation', value='-', extensions={}, annotations={}), 'code': Annotation(tag='code', value='-', extensions={}, annotations={})}, 'comments': ['a use case for this is for a field that has been deprecated', 'a use case for this is for annotating a field that is not applicable in a particular context']} zero_or_one not required, single-valued carvoc:ZeroToOne {'mixins': ['optional', 'single-valued'], 'annotations': {'maps_to': Annotation(tag='maps_to', value='{required: false, multivalued: false}', extensions={}, annotations={}), 'min': Annotation(tag='min', value='0', extensions={}, annotations={}), 'max': Annotation(tag='max', value='1', extensions={}, annotations={}), 'interpretation': Annotation(tag='interpretation', value='MUST, MAY', extensions={}, annotations={}), 'uml': Annotation(tag='uml', value='0..1', extensions={}, annotations={}), 'code': Annotation(tag='code', value='0..1', extensions={}, annotations={})}} exactly_one required, single-valued carvoc:ExactlyOne {'mixins': ['mandatory', 'single-valued'], 'annotations': {'maps_to': Annotation(tag='maps_to', value='{required: true, multivalued: false}', extensions={}, annotations={}), 'min': Annotation(tag='min', value='1', extensions={}, annotations={}), 'max': Annotation(tag='max', value='1', extensions={}, annotations={}), 'interpretation': Annotation(tag='interpretation', value='MUST', extensions={}, annotations={}), 'uml': Annotation(tag='uml', value='1..1', extensions={}, annotations={}), 'code': Annotation(tag='code', value='1..1', extensions={}, annotations={})}} zero_to_many not required, multi-valued carvoc:ZeroToMany {'mixins': ['optional', 'multi-valued'], 'annotations': {'maps_to': Annotation(tag='maps_to', value='{required: false, multivalued: true}', extensions={}, annotations={}), 'min': Annotation(tag='min', value='0', extensions={}, annotations={}), 'max': Annotation(tag='max', value=' ', extensions={}, annotations={}), 'interpretation': Annotation(tag='interpretation', value='MAY', extensions={}, annotations={}), 'uml': Annotation(tag='uml', value='0.. ', extensions={}, annotations={}), 'code': Annotation(tag='code', value='0..*', extensions={}, annotations={})}} one_to_many required, multi-valued carvoc:OneToMany {'mixins': ['mandatory', 'multi-valued'], 'annotations': {'maps_to': Annotation(tag='maps_to', value='{required: true, multivalued: true}', extensions={}, annotations={}), 'min': Annotation(tag='min', value='1', extensions={}, annotations={}), 'max': Annotation(tag='max', value=' ', extensions={}, annotations={}), 'interpretation': Annotation(tag='interpretation', value='MUST, MAY', extensions={}, annotations={}), 'uml': Annotation(tag='uml', value='1.. ', extensions={}, annotations={}), 'code': Annotation(tag='code', value='1..*', extensions={}, annotations={})}} single_valued not multi-valued carvoc:SingleValued {'annotations': {'maps_to': Annotation(tag='maps_to', value='multivalued: false', extensions={}, annotations={}), 'max': Annotation(tag='max', value='1', extensions={}, annotations={}), 'opposite': Annotation(tag='opposite', value='multi-valued', extensions={}, annotations={}), 'interpretation': Annotation(tag='interpretation', value='MAY', extensions={}, annotations={}), 'mixs_notation': Annotation(tag='mixs_notation', value='1', extensions={}, annotations={}), 'code': Annotation(tag='code', value='SV', extensions={}, annotations={})}} multi_valued multi-valued carvoc:MultiValued {'annotations': {'maps_to': Annotation(tag='maps_to', value='multivalued: true', extensions={}, annotations={}), 'max': Annotation(tag='max', value='*', extensions={}, annotations={}), 'opposite': Annotation(tag='opposite', value='single-valued', extensions={}, annotations={}), 'interpretation': Annotation(tag='interpretation', value='MAY', extensions={}, annotations={}), 'mixs_notation': Annotation(tag='mixs_notation', value='m', extensions={}, annotations={}), 'code': Annotation(tag='code', value='MV', extensions={}, annotations={})}} conditional A qualifier on cardinalities that indicates the interpretation is context-dependent carvoc:Conditional {'annotations': {'maps_to': Annotation(tag='maps_to', value='conditional: true', extensions={}, annotations={}), 'mixs_notation': Annotation(tag='mixs_notation', value='E', extensions={}, annotations={}), 'code': Annotation(tag='code', value='E+', extensions={}, annotations={})}} unconditional A qualifier on cardinalities that indicates the interpretation is context-independent carvoc:Unconditional {'annotations': {'maps_to': Annotation(tag='maps_to', value='conditional: false', extensions={}, annotations={}), 'code': Annotation(tag='code', value='E-', extensions={}, annotations={})}} conditional_mandatory carvoc:ConditionalMandatory {'mixins': ['mandatory', 'conditional'], 'annotations': {'maps_to': Annotation(tag='maps_to', value='{required: true, conditional: true}', extensions={}, annotations={}), 'mixs_notation': Annotation(tag='mixs_notation', value='C', extensions={}, annotations={}), 'code': Annotation(tag='code', value='EM', extensions={}, annotations={})}}","title":"Permissible Values"},{"location":"datamodel/ColumnSettings/","text":"Class: ColumnSettings configuration for an individual column in a schema sheet. These settings are typically specified as YAML blocks beneath the relevant column header, for example: > class URI: schemasheets:ColumnSettings Attributes Own \u279ecurie_prefix 0..1 Description: CURIE prefix prepended to column value. This may be used for column that describe mapping or class/slot uri properties of the element. For example, with column settings exact_mapping: {curie_prefix: dcterms} , an element row with column value contributor , the value will be transformed to dcterms:contributor Range: String \u279eprefix 0..1 Description: string to be prefixed onto the column value Range: String \u279esuffix 0..1 Description: string to be suffixied onto the column value Range: String \u279etemplate 0..1 Description: jinja templated format string Range: String \u279evmap 0..* Description: Specifies a mapping for column values Range: ValueMap \u279eapplies_to_class 0..1 Description: if a value C is specified, then this column in the relevant row is interpreted as pertaining to C Range: ElementReference \u279eapplies_to_slot 0..1 Range: ElementReference \u279etag 0..1 Range: String","title":"Class: ColumnSettings"},{"location":"datamodel/ColumnSettings/#class-columnsettings","text":"configuration for an individual column in a schema sheet. These settings are typically specified as YAML blocks beneath the relevant column header, for example: > class URI: schemasheets:ColumnSettings","title":"Class: ColumnSettings"},{"location":"datamodel/ColumnSettings/#attributes","text":"","title":"Attributes"},{"location":"datamodel/ColumnSettings/#own","text":"\u279ecurie_prefix 0..1 Description: CURIE prefix prepended to column value. This may be used for column that describe mapping or class/slot uri properties of the element. For example, with column settings exact_mapping: {curie_prefix: dcterms} , an element row with column value contributor , the value will be transformed to dcterms:contributor Range: String \u279eprefix 0..1 Description: string to be prefixed onto the column value Range: String \u279esuffix 0..1 Description: string to be suffixied onto the column value Range: String \u279etemplate 0..1 Description: jinja templated format string Range: String \u279evmap 0..* Description: Specifies a mapping for column values Range: ValueMap \u279eapplies_to_class 0..1 Description: if a value C is specified, then this column in the relevant row is interpreted as pertaining to C Range: ElementReference \u279eapplies_to_slot 0..1 Range: ElementReference \u279etag 0..1 Range: String","title":"Own"},{"location":"datamodel/Shortcuts/","text":"Enum: Shortcuts A vocabulary of permissible values as column descriptors that do not have an exact equivalent in the LinkML datamodel, and instead act as shortcuts to either a collection of elements or a type of mapping behavior URI: schemasheets:Shortcuts Other properties Permissible Values Text Description Meaning Other Information cardinality The column is used to describe the cardinality of a slot, with values from the Cardinality enum ignore The column is ignored metatype The column describes what kind of element is specified in the row class The column is populated with class names linkml:ClassDefinition slot The column is populated with slot names linkml:SlotDefinition enum The column is populated with enum names linkml:EnumDefinition schema The column is populated with schema names linkml:EnumDefinition subset The column is populated with subset names linkml:EnumDefinition","title":"Enum: Shortcuts"},{"location":"datamodel/Shortcuts/#enum-shortcuts","text":"A vocabulary of permissible values as column descriptors that do not have an exact equivalent in the LinkML datamodel, and instead act as shortcuts to either a collection of elements or a type of mapping behavior URI: schemasheets:Shortcuts","title":"Enum: Shortcuts"},{"location":"datamodel/Shortcuts/#other-properties","text":"","title":"Other properties"},{"location":"datamodel/Shortcuts/#permissible-values","text":"Text Description Meaning Other Information cardinality The column is used to describe the cardinality of a slot, with values from the Cardinality enum ignore The column is ignored metatype The column describes what kind of element is specified in the row class The column is populated with class names linkml:ClassDefinition slot The column is populated with slot names linkml:SlotDefinition enum The column is populated with enum names linkml:EnumDefinition schema The column is populated with schema names linkml:EnumDefinition subset The column is populated with subset names linkml:EnumDefinition","title":"Permissible Values"},{"location":"datamodel/ValueMap/","text":"Class: ValueMap A key-value dictionary URI: schemasheets:ValueMap Referenced by Class None \u279evmap 0..* ValueMap Attributes Own map_key 1..1 Description: key in the dictionary Range: String map_value 0..1 Description: key in the dictionary Range: String","title":"Class: ValueMap"},{"location":"datamodel/ValueMap/#class-valuemap","text":"A key-value dictionary URI: schemasheets:ValueMap","title":"Class: ValueMap"},{"location":"datamodel/ValueMap/#referenced-by-class","text":"None \u279evmap 0..* ValueMap","title":"Referenced by Class"},{"location":"datamodel/ValueMap/#attributes","text":"","title":"Attributes"},{"location":"datamodel/ValueMap/#own","text":"map_key 1..1 Description: key in the dictionary Range: String map_value 0..1 Description: key in the dictionary Range: String","title":"Own"},{"location":"datamodel/columnSettings__applies_to_class/","text":"Slot: applies_to_class if a value C is specified, then this column in the relevant row is interpreted as pertaining to C URI: schemasheets:columnSettings__applies_to_class Domain and Range None \u2192 0..1 ElementReference Parents Children Used by ColumnSettings","title":"Slot: applies_to_class"},{"location":"datamodel/columnSettings__applies_to_class/#slot-applies_to_class","text":"if a value C is specified, then this column in the relevant row is interpreted as pertaining to C URI: schemasheets:columnSettings__applies_to_class","title":"Slot: applies_to_class"},{"location":"datamodel/columnSettings__applies_to_class/#domain-and-range","text":"None \u2192 0..1 ElementReference","title":"Domain and Range"},{"location":"datamodel/columnSettings__applies_to_class/#parents","text":"","title":"Parents"},{"location":"datamodel/columnSettings__applies_to_class/#children","text":"","title":"Children"},{"location":"datamodel/columnSettings__applies_to_class/#used-by","text":"ColumnSettings","title":"Used by"},{"location":"datamodel/columnSettings__applies_to_slot/","text":"Slot: applies_to_slot URI: schemasheets:columnSettings__applies_to_slot Domain and Range None \u2192 0..1 ElementReference Parents Children Used by ColumnSettings","title":"Slot: applies_to_slot"},{"location":"datamodel/columnSettings__applies_to_slot/#slot-applies_to_slot","text":"URI: schemasheets:columnSettings__applies_to_slot","title":"Slot: applies_to_slot"},{"location":"datamodel/columnSettings__applies_to_slot/#domain-and-range","text":"None \u2192 0..1 ElementReference","title":"Domain and Range"},{"location":"datamodel/columnSettings__applies_to_slot/#parents","text":"","title":"Parents"},{"location":"datamodel/columnSettings__applies_to_slot/#children","text":"","title":"Children"},{"location":"datamodel/columnSettings__applies_to_slot/#used-by","text":"ColumnSettings","title":"Used by"},{"location":"datamodel/columnSettings__curie_prefix/","text":"Slot: curie_prefix CURIE prefix prepended to column value. This may be used for column that describe mapping or class/slot uri properties of the element. For example, with column settings exact_mapping: {curie_prefix: dcterms} , an element row with column value contributor , the value will be transformed to dcterms:contributor URI: schemasheets:columnSettings__curie_prefix Domain and Range None \u2192 0..1 String Parents Children Used by ColumnSettings","title":"Slot: curie_prefix"},{"location":"datamodel/columnSettings__curie_prefix/#slot-curie_prefix","text":"CURIE prefix prepended to column value. This may be used for column that describe mapping or class/slot uri properties of the element. For example, with column settings exact_mapping: {curie_prefix: dcterms} , an element row with column value contributor , the value will be transformed to dcterms:contributor URI: schemasheets:columnSettings__curie_prefix","title":"Slot: curie_prefix"},{"location":"datamodel/columnSettings__curie_prefix/#domain-and-range","text":"None \u2192 0..1 String","title":"Domain and Range"},{"location":"datamodel/columnSettings__curie_prefix/#parents","text":"","title":"Parents"},{"location":"datamodel/columnSettings__curie_prefix/#children","text":"","title":"Children"},{"location":"datamodel/columnSettings__curie_prefix/#used-by","text":"ColumnSettings","title":"Used by"},{"location":"datamodel/columnSettings__prefix/","text":"Slot: prefix string to be prefixed onto the column value URI: schemasheets:columnSettings__prefix Domain and Range None \u2192 0..1 String Parents Children Used by ColumnSettings","title":"Slot: prefix"},{"location":"datamodel/columnSettings__prefix/#slot-prefix","text":"string to be prefixed onto the column value URI: schemasheets:columnSettings__prefix","title":"Slot: prefix"},{"location":"datamodel/columnSettings__prefix/#domain-and-range","text":"None \u2192 0..1 String","title":"Domain and Range"},{"location":"datamodel/columnSettings__prefix/#parents","text":"","title":"Parents"},{"location":"datamodel/columnSettings__prefix/#children","text":"","title":"Children"},{"location":"datamodel/columnSettings__prefix/#used-by","text":"ColumnSettings","title":"Used by"},{"location":"datamodel/columnSettings__suffix/","text":"Slot: suffix string to be suffixied onto the column value URI: schemasheets:columnSettings__suffix Domain and Range None \u2192 0..1 String Parents Children Used by ColumnSettings","title":"Slot: suffix"},{"location":"datamodel/columnSettings__suffix/#slot-suffix","text":"string to be suffixied onto the column value URI: schemasheets:columnSettings__suffix","title":"Slot: suffix"},{"location":"datamodel/columnSettings__suffix/#domain-and-range","text":"None \u2192 0..1 String","title":"Domain and Range"},{"location":"datamodel/columnSettings__suffix/#parents","text":"","title":"Parents"},{"location":"datamodel/columnSettings__suffix/#children","text":"","title":"Children"},{"location":"datamodel/columnSettings__suffix/#used-by","text":"ColumnSettings","title":"Used by"},{"location":"datamodel/columnSettings__tag/","text":"Slot: tag URI: schemasheets:columnSettings__tag Domain and Range None \u2192 0..1 String Parents Children Used by ColumnSettings","title":"Slot: tag"},{"location":"datamodel/columnSettings__tag/#slot-tag","text":"URI: schemasheets:columnSettings__tag","title":"Slot: tag"},{"location":"datamodel/columnSettings__tag/#domain-and-range","text":"None \u2192 0..1 String","title":"Domain and Range"},{"location":"datamodel/columnSettings__tag/#parents","text":"","title":"Parents"},{"location":"datamodel/columnSettings__tag/#children","text":"","title":"Children"},{"location":"datamodel/columnSettings__tag/#used-by","text":"ColumnSettings","title":"Used by"},{"location":"datamodel/columnSettings__template/","text":"Slot: template jinja templated format string URI: schemasheets:columnSettings__template Domain and Range None \u2192 0..1 String Parents Children Used by ColumnSettings","title":"Slot: template"},{"location":"datamodel/columnSettings__template/#slot-template","text":"jinja templated format string URI: schemasheets:columnSettings__template","title":"Slot: template"},{"location":"datamodel/columnSettings__template/#domain-and-range","text":"None \u2192 0..1 String","title":"Domain and Range"},{"location":"datamodel/columnSettings__template/#parents","text":"","title":"Parents"},{"location":"datamodel/columnSettings__template/#children","text":"","title":"Children"},{"location":"datamodel/columnSettings__template/#used-by","text":"ColumnSettings","title":"Used by"},{"location":"datamodel/columnSettings__vmap/","text":"Slot: vmap Specifies a mapping for column values URI: schemasheets:columnSettings__vmap Domain and Range None \u2192 0..* ValueMap Parents Children Used by ColumnSettings","title":"Slot: vmap"},{"location":"datamodel/columnSettings__vmap/#slot-vmap","text":"Specifies a mapping for column values URI: schemasheets:columnSettings__vmap","title":"Slot: vmap"},{"location":"datamodel/columnSettings__vmap/#domain-and-range","text":"None \u2192 0..* ValueMap","title":"Domain and Range"},{"location":"datamodel/columnSettings__vmap/#parents","text":"","title":"Parents"},{"location":"datamodel/columnSettings__vmap/#children","text":"","title":"Children"},{"location":"datamodel/columnSettings__vmap/#used-by","text":"ColumnSettings","title":"Used by"},{"location":"datamodel/map_key/","text":"Slot: map_key key in the dictionary URI: schemasheets:map_key Domain and Range None \u2192 1..1 String Parents Children Used by ValueMap","title":"Slot: map_key"},{"location":"datamodel/map_key/#slot-map_key","text":"key in the dictionary URI: schemasheets:map_key","title":"Slot: map_key"},{"location":"datamodel/map_key/#domain-and-range","text":"None \u2192 1..1 String","title":"Domain and Range"},{"location":"datamodel/map_key/#parents","text":"","title":"Parents"},{"location":"datamodel/map_key/#children","text":"","title":"Children"},{"location":"datamodel/map_key/#used-by","text":"ValueMap","title":"Used by"},{"location":"datamodel/map_value/","text":"Slot: map_value key in the dictionary URI: schemasheets:map_value Domain and Range None \u2192 0..1 String Parents Children Used by ValueMap","title":"Slot: map_value"},{"location":"datamodel/map_value/#slot-map_value","text":"key in the dictionary URI: schemasheets:map_value","title":"Slot: map_value"},{"location":"datamodel/map_value/#domain-and-range","text":"None \u2192 0..1 String","title":"Domain and Range"},{"location":"datamodel/map_value/#parents","text":"","title":"Parents"},{"location":"datamodel/map_value/#children","text":"","title":"Children"},{"location":"datamodel/map_value/#used-by","text":"ValueMap","title":"Used by"},{"location":"datamodel/docs/A/","text":"Subset: a URI: TEMP:a Classes Event - grouping class for events Mixins Slots Types Enums","title":"Subset: a"},{"location":"datamodel/docs/A/#subset-a","text":"URI: TEMP:a","title":"Subset: a"},{"location":"datamodel/docs/A/#classes","text":"Event - grouping class for events","title":"Classes"},{"location":"datamodel/docs/A/#mixins","text":"","title":"Mixins"},{"location":"datamodel/docs/A/#slots","text":"","title":"Slots"},{"location":"datamodel/docs/A/#types","text":"","title":"Types"},{"location":"datamodel/docs/A/#enums","text":"","title":"Enums"},{"location":"datamodel/docs/B/","text":"Subset: b URI: TEMP:b Classes MedicalEvent - a medical encounter Mixins Slots Types Enums","title":"Subset: b"},{"location":"datamodel/docs/B/#subset-b","text":"URI: TEMP:b","title":"Subset: b"},{"location":"datamodel/docs/B/#classes","text":"MedicalEvent - a medical encounter","title":"Classes"},{"location":"datamodel/docs/B/#mixins","text":"","title":"Mixins"},{"location":"datamodel/docs/B/#slots","text":"","title":"Slots"},{"location":"datamodel/docs/B/#types","text":"","title":"Types"},{"location":"datamodel/docs/B/#enums","text":"","title":"Enums"},{"location":"datamodel/docs/Event/","text":"Class: Event grouping class for events URI: TEMP:Event Children MedicalEvent - a medical encounter Referenced by Class Attributes Other properties In Subsets: a Exact Mappings: wikidata:Q1656682","title":"Class: Event"},{"location":"datamodel/docs/Event/#class-event","text":"grouping class for events URI: TEMP:Event","title":"Class: Event"},{"location":"datamodel/docs/Event/#children","text":"MedicalEvent - a medical encounter","title":"Children"},{"location":"datamodel/docs/Event/#referenced-by-class","text":"","title":"Referenced by Class"},{"location":"datamodel/docs/Event/#attributes","text":"","title":"Attributes"},{"location":"datamodel/docs/Event/#other-properties","text":"In Subsets: a Exact Mappings: wikidata:Q1656682","title":"Other properties"},{"location":"datamodel/docs/ForProfit/","text":"Class: ForProfit URI: TEMP:ForProfit Parents is_a: Organization Attributes Inherited from Organization: Organization\u279ename 1..1 Description: full name Range: String","title":"Class: ForProfit"},{"location":"datamodel/docs/ForProfit/#class-forprofit","text":"URI: TEMP:ForProfit","title":"Class: ForProfit"},{"location":"datamodel/docs/ForProfit/#parents","text":"is_a: Organization","title":"Parents"},{"location":"datamodel/docs/ForProfit/#attributes","text":"","title":"Attributes"},{"location":"datamodel/docs/ForProfit/#inherited-from-organization","text":"Organization\u279ename 1..1 Description: full name Range: String","title":"Inherited from Organization:"},{"location":"datamodel/docs/MedicalEvent/","text":"Class: MedicalEvent a medical encounter URI: TEMP:MedicalEvent Parents is_a: Event - grouping class for events Referenced by Class Person Person\u279ehas medical history 0..* MedicalEvent Attributes Other properties In Subsets: b","title":"Class: MedicalEvent"},{"location":"datamodel/docs/MedicalEvent/#class-medicalevent","text":"a medical encounter URI: TEMP:MedicalEvent","title":"Class: MedicalEvent"},{"location":"datamodel/docs/MedicalEvent/#parents","text":"is_a: Event - grouping class for events","title":"Parents"},{"location":"datamodel/docs/MedicalEvent/#referenced-by-class","text":"Person Person\u279ehas medical history 0..* MedicalEvent","title":"Referenced by Class"},{"location":"datamodel/docs/MedicalEvent/#attributes","text":"","title":"Attributes"},{"location":"datamodel/docs/MedicalEvent/#other-properties","text":"In Subsets: b","title":"Other properties"},{"location":"datamodel/docs/NonProfit/","text":"Class: NonProfit URI: TEMP:NonProfit Parents is_a: Organization Attributes Inherited from Organization: Organization\u279ename 1..1 Description: full name Range: String Other properties Exact Mappings: wikidata:Q163740","title":"Class: NonProfit"},{"location":"datamodel/docs/NonProfit/#class-nonprofit","text":"URI: TEMP:NonProfit","title":"Class: NonProfit"},{"location":"datamodel/docs/NonProfit/#parents","text":"is_a: Organization","title":"Parents"},{"location":"datamodel/docs/NonProfit/#attributes","text":"","title":"Attributes"},{"location":"datamodel/docs/NonProfit/#inherited-from-organization","text":"Organization\u279ename 1..1 Description: full name Range: String","title":"Inherited from Organization:"},{"location":"datamodel/docs/NonProfit/#other-properties","text":"Exact Mappings: wikidata:Q163740","title":"Other properties"},{"location":"datamodel/docs/Organization/","text":"Class: Organization URI: TEMP:Organization Children ForProfit NonProfit Referenced by Class Attributes Own Organization\u279ename 1..1 Description: full name Range: String","title":"Class: Organization"},{"location":"datamodel/docs/Organization/#class-organization","text":"URI: TEMP:Organization","title":"Class: Organization"},{"location":"datamodel/docs/Organization/#children","text":"ForProfit NonProfit","title":"Children"},{"location":"datamodel/docs/Organization/#referenced-by-class","text":"","title":"Referenced by Class"},{"location":"datamodel/docs/Organization/#attributes","text":"","title":"Attributes"},{"location":"datamodel/docs/Organization/#own","text":"Organization\u279ename 1..1 Description: full name Range: String","title":"Own"},{"location":"datamodel/docs/Organization_name/","text":"Slot: name full name URI: TEMP:Organization_name Domain and Range Organization \u2192 1..1 String Parents is_a: name Children Used by ForProfit NonProfit Organization Other properties Exact Mappings: sdo:name","title":"Slot: name"},{"location":"datamodel/docs/Organization_name/#slot-name","text":"full name URI: TEMP:Organization_name","title":"Slot: name"},{"location":"datamodel/docs/Organization_name/#domain-and-range","text":"Organization \u2192 1..1 String","title":"Domain and Range"},{"location":"datamodel/docs/Organization_name/#parents","text":"is_a: name","title":"Parents"},{"location":"datamodel/docs/Organization_name/#children","text":"","title":"Children"},{"location":"datamodel/docs/Organization_name/#used-by","text":"ForProfit NonProfit Organization","title":"Used by"},{"location":"datamodel/docs/Organization_name/#other-properties","text":"Exact Mappings: sdo:name","title":"Other properties"},{"location":"datamodel/docs/Person/","text":"Class: Person a person,living or dead URI: TEMP:Person Referenced by Class Attributes Own Person\u279eid 1..1 Description: identifier for a person Range: String Person\u279ename 1..1 Description: full name Range: String Person\u279eage 0..1 Description: age in years Range: Decimal Person\u279egender 0..1 Description: age in years Range: Decimal Person\u279ehas medical history 0..* Description: medical history Range: MedicalEvent Other properties Exact Mappings: sdo:Person wikidata:Q215627","title":"Class: Person"},{"location":"datamodel/docs/Person/#class-person","text":"a person,living or dead URI: TEMP:Person","title":"Class: Person"},{"location":"datamodel/docs/Person/#referenced-by-class","text":"","title":"Referenced by Class"},{"location":"datamodel/docs/Person/#attributes","text":"","title":"Attributes"},{"location":"datamodel/docs/Person/#own","text":"Person\u279eid 1..1 Description: identifier for a person Range: String Person\u279ename 1..1 Description: full name Range: String Person\u279eage 0..1 Description: age in years Range: Decimal Person\u279egender 0..1 Description: age in years Range: Decimal Person\u279ehas medical history 0..* Description: medical history Range: MedicalEvent","title":"Own"},{"location":"datamodel/docs/Person/#other-properties","text":"Exact Mappings: sdo:Person wikidata:Q215627","title":"Other properties"},{"location":"datamodel/docs/Person_age/","text":"Slot: age age in years URI: TEMP:Person_age Domain and Range Person \u2192 0..1 Decimal Parents is_a: age Children Used by Person","title":"Slot: age"},{"location":"datamodel/docs/Person_age/#slot-age","text":"age in years URI: TEMP:Person_age","title":"Slot: age"},{"location":"datamodel/docs/Person_age/#domain-and-range","text":"Person \u2192 0..1 Decimal","title":"Domain and Range"},{"location":"datamodel/docs/Person_age/#parents","text":"is_a: age","title":"Parents"},{"location":"datamodel/docs/Person_age/#children","text":"","title":"Children"},{"location":"datamodel/docs/Person_age/#used-by","text":"Person","title":"Used by"},{"location":"datamodel/docs/Person_gender/","text":"Slot: gender age in years URI: TEMP:Person_gender Domain and Range Person \u2192 0..1 Decimal Parents is_a: gender Children Used by Person","title":"Slot: gender"},{"location":"datamodel/docs/Person_gender/#slot-gender","text":"age in years URI: TEMP:Person_gender","title":"Slot: gender"},{"location":"datamodel/docs/Person_gender/#domain-and-range","text":"Person \u2192 0..1 Decimal","title":"Domain and Range"},{"location":"datamodel/docs/Person_gender/#parents","text":"is_a: gender","title":"Parents"},{"location":"datamodel/docs/Person_gender/#children","text":"","title":"Children"},{"location":"datamodel/docs/Person_gender/#used-by","text":"Person","title":"Used by"},{"location":"datamodel/docs/Person_has_medical_history/","text":"Slot: has medical history medical history URI: TEMP:Person_has_medical_history Domain and Range Person \u2192 0..* MedicalEvent Parents is_a: has medical history Children Used by Person","title":"Slot: has medical history"},{"location":"datamodel/docs/Person_has_medical_history/#slot-has-medical-history","text":"medical history URI: TEMP:Person_has_medical_history","title":"Slot: has medical history"},{"location":"datamodel/docs/Person_has_medical_history/#domain-and-range","text":"Person \u2192 0..* MedicalEvent","title":"Domain and Range"},{"location":"datamodel/docs/Person_has_medical_history/#parents","text":"is_a: has medical history","title":"Parents"},{"location":"datamodel/docs/Person_has_medical_history/#children","text":"","title":"Children"},{"location":"datamodel/docs/Person_has_medical_history/#used-by","text":"Person","title":"Used by"},{"location":"datamodel/docs/Person_id/","text":"Slot: id identifier for a person URI: TEMP:Person_id Domain and Range Person \u2192 1..1 String Parents is_a: id Children Used by Person Other properties Exact Mappings: sdo:identifier","title":"Slot: id"},{"location":"datamodel/docs/Person_id/#slot-id","text":"identifier for a person URI: TEMP:Person_id","title":"Slot: id"},{"location":"datamodel/docs/Person_id/#domain-and-range","text":"Person \u2192 1..1 String","title":"Domain and Range"},{"location":"datamodel/docs/Person_id/#parents","text":"is_a: id","title":"Parents"},{"location":"datamodel/docs/Person_id/#children","text":"","title":"Children"},{"location":"datamodel/docs/Person_id/#used-by","text":"Person","title":"Used by"},{"location":"datamodel/docs/Person_id/#other-properties","text":"Exact Mappings: sdo:identifier","title":"Other properties"},{"location":"datamodel/docs/Person_name/","text":"Slot: name full name URI: TEMP:Person_name Domain and Range Person \u2192 1..1 String Parents is_a: name Children Used by Person Other properties Exact Mappings: sdo:name","title":"Slot: name"},{"location":"datamodel/docs/Person_name/#slot-name","text":"full name URI: TEMP:Person_name","title":"Slot: name"},{"location":"datamodel/docs/Person_name/#domain-and-range","text":"Person \u2192 1..1 String","title":"Domain and Range"},{"location":"datamodel/docs/Person_name/#parents","text":"is_a: name","title":"Parents"},{"location":"datamodel/docs/Person_name/#children","text":"","title":"Children"},{"location":"datamodel/docs/Person_name/#used-by","text":"Person","title":"Used by"},{"location":"datamodel/docs/Person_name/#other-properties","text":"Exact Mappings: sdo:name","title":"Other properties"},{"location":"datamodel/docs/age/","text":"Slot: age URI: TEMP:age Domain and Range None \u2192 0..1 String Parents Children Person\u279eage Used by","title":"Slot: age"},{"location":"datamodel/docs/age/#slot-age","text":"URI: TEMP:age","title":"Slot: age"},{"location":"datamodel/docs/age/#domain-and-range","text":"None \u2192 0..1 String","title":"Domain and Range"},{"location":"datamodel/docs/age/#parents","text":"","title":"Parents"},{"location":"datamodel/docs/age/#children","text":"Person\u279eage","title":"Children"},{"location":"datamodel/docs/age/#used-by","text":"","title":"Used by"},{"location":"datamodel/docs/description/","text":"Slot: description a textual description URI: TEMP:description Domain and Range None \u2192 0..1 String Parents Children Used by Other properties Exact Mappings: sdo:description","title":"Slot: description"},{"location":"datamodel/docs/description/#slot-description","text":"a textual description URI: TEMP:description","title":"Slot: description"},{"location":"datamodel/docs/description/#domain-and-range","text":"None \u2192 0..1 String","title":"Domain and Range"},{"location":"datamodel/docs/description/#parents","text":"","title":"Parents"},{"location":"datamodel/docs/description/#children","text":"","title":"Children"},{"location":"datamodel/docs/description/#used-by","text":"","title":"Used by"},{"location":"datamodel/docs/description/#other-properties","text":"Exact Mappings: sdo:description","title":"Other properties"},{"location":"datamodel/docs/gender/","text":"Slot: gender URI: TEMP:gender Domain and Range None \u2192 0..1 String Parents Children Person\u279egender Used by","title":"Slot: gender"},{"location":"datamodel/docs/gender/#slot-gender","text":"URI: TEMP:gender","title":"Slot: gender"},{"location":"datamodel/docs/gender/#domain-and-range","text":"None \u2192 0..1 String","title":"Domain and Range"},{"location":"datamodel/docs/gender/#parents","text":"","title":"Parents"},{"location":"datamodel/docs/gender/#children","text":"Person\u279egender","title":"Children"},{"location":"datamodel/docs/gender/#used-by","text":"","title":"Used by"},{"location":"datamodel/docs/has_medical_history/","text":"Slot: has medical history URI: TEMP:has_medical_history Domain and Range None \u2192 0..1 String Parents Children Person\u279ehas medical history Used by","title":"Slot: has medical history"},{"location":"datamodel/docs/has_medical_history/#slot-has-medical-history","text":"URI: TEMP:has_medical_history","title":"Slot: has medical history"},{"location":"datamodel/docs/has_medical_history/#domain-and-range","text":"None \u2192 0..1 String","title":"Domain and Range"},{"location":"datamodel/docs/has_medical_history/#parents","text":"","title":"Parents"},{"location":"datamodel/docs/has_medical_history/#children","text":"Person\u279ehas medical history","title":"Children"},{"location":"datamodel/docs/has_medical_history/#used-by","text":"","title":"Used by"},{"location":"datamodel/docs/id/","text":"Slot: id any identifier URI: TEMP:id Domain and Range None \u2192 1..1 String Parents Children Person\u279eid Used by Other properties Exact Mappings: sdo:identifier","title":"Slot: id"},{"location":"datamodel/docs/id/#slot-id","text":"any identifier URI: TEMP:id","title":"Slot: id"},{"location":"datamodel/docs/id/#domain-and-range","text":"None \u2192 1..1 String","title":"Domain and Range"},{"location":"datamodel/docs/id/#parents","text":"","title":"Parents"},{"location":"datamodel/docs/id/#children","text":"Person\u279eid","title":"Children"},{"location":"datamodel/docs/id/#used-by","text":"","title":"Used by"},{"location":"datamodel/docs/id/#other-properties","text":"Exact Mappings: sdo:identifier","title":"Other properties"},{"location":"datamodel/docs/name/","text":"Slot: name URI: TEMP:name Domain and Range None \u2192 0..1 String Parents Children Organization\u279ename Person\u279ename Used by","title":"Slot: name"},{"location":"datamodel/docs/name/#slot-name","text":"URI: TEMP:name","title":"Slot: name"},{"location":"datamodel/docs/name/#domain-and-range","text":"None \u2192 0..1 String","title":"Domain and Range"},{"location":"datamodel/docs/name/#parents","text":"","title":"Parents"},{"location":"datamodel/docs/name/#children","text":"Organization\u279ename Person\u279ename","title":"Children"},{"location":"datamodel/docs/name/#used-by","text":"","title":"Used by"},{"location":"datamodel/docs/schema/","text":"TEMP schema Classes Event - grouping class for events MedicalEvent - a medical encounter Organization ForProfit NonProfit Person - a person,living or dead Mixins Slots age Person\u279eage - age in years description - a textual description gender Person\u279egender - age in years has medical history Person\u279ehas medical history - medical history id - any identifier Person\u279eid - identifier for a person name Organization\u279ename - full name Person\u279ename - full name Enums Subsets A B Types Built in Bool Decimal ElementIdentifier NCName NodeIdentifier URI URIorCURIE XSDDate XSDDateTime XSDTime float int str Defined Boolean ( Bool ) - A binary (true or false) value Date ( XSDDate ) - a date (year, month and day) in an idealized calendar Datetime ( XSDDateTime ) - The combination of a date and time Decimal ( Decimal ) - A real number with arbitrary precision that conforms to the xsd:decimal specification Double ( float ) - A real number that conforms to the xsd:double specification Float ( float ) - A real number that conforms to the xsd:float specification Integer ( int ) - An integer Ncname ( NCName ) - Prefix part of CURIE Nodeidentifier ( NodeIdentifier ) - A URI, CURIE or BNODE that represents a node in a model. Objectidentifier ( ElementIdentifier ) - A URI or CURIE that represents an object in the model. String ( str ) - A character string Time ( XSDTime ) - A time object represents a (local) time of day, independent of any particular day Uri ( URI ) - a complete URI Uriorcurie ( URIorCURIE ) - a URI or a CURIE","title":"TEMP schema"},{"location":"datamodel/docs/schema/#temp-schema","text":"","title":"TEMP schema"},{"location":"datamodel/docs/schema/#classes","text":"Event - grouping class for events MedicalEvent - a medical encounter Organization ForProfit NonProfit Person - a person,living or dead","title":"Classes"},{"location":"datamodel/docs/schema/#mixins","text":"","title":"Mixins"},{"location":"datamodel/docs/schema/#slots","text":"age Person\u279eage - age in years description - a textual description gender Person\u279egender - age in years has medical history Person\u279ehas medical history - medical history id - any identifier Person\u279eid - identifier for a person name Organization\u279ename - full name Person\u279ename - full name","title":"Slots"},{"location":"datamodel/docs/schema/#enums","text":"","title":"Enums"},{"location":"datamodel/docs/schema/#subsets","text":"A B","title":"Subsets"},{"location":"datamodel/docs/schema/#types","text":"","title":"Types"},{"location":"datamodel/docs/schema/#built-in","text":"Bool Decimal ElementIdentifier NCName NodeIdentifier URI URIorCURIE XSDDate XSDDateTime XSDTime float int str","title":"Built in"},{"location":"datamodel/docs/schema/#defined","text":"Boolean ( Bool ) - A binary (true or false) value Date ( XSDDate ) - a date (year, month and day) in an idealized calendar Datetime ( XSDDateTime ) - The combination of a date and time Decimal ( Decimal ) - A real number with arbitrary precision that conforms to the xsd:decimal specification Double ( float ) - A real number that conforms to the xsd:double specification Float ( float ) - A real number that conforms to the xsd:float specification Integer ( int ) - An integer Ncname ( NCName ) - Prefix part of CURIE Nodeidentifier ( NodeIdentifier ) - A URI, CURIE or BNODE that represents a node in a model. Objectidentifier ( ElementIdentifier ) - A URI or CURIE that represents an object in the model. String ( str ) - A character string Time ( XSDTime ) - A time object represents a (local) time of day, independent of any particular day Uri ( URI ) - a complete URI Uriorcurie ( URIorCURIE ) - a URI or a CURIE","title":"Defined"},{"location":"datamodel/types/Boolean/","text":"Type: boolean A binary (true or false) value URI: linkml:Boolean Root (builtin) type Bool Representation bool","title":"Type: boolean"},{"location":"datamodel/types/Boolean/#type-boolean","text":"A binary (true or false) value URI: linkml:Boolean Root (builtin) type Bool Representation bool","title":"Type: boolean"},{"location":"datamodel/types/Date/","text":"Type: date a date (year, month and day) in an idealized calendar URI: linkml:Date Root (builtin) type XSDDate Representation str","title":"Type: date"},{"location":"datamodel/types/Date/#type-date","text":"a date (year, month and day) in an idealized calendar URI: linkml:Date Root (builtin) type XSDDate Representation str","title":"Type: date"},{"location":"datamodel/types/Datetime/","text":"Type: datetime The combination of a date and time URI: linkml:Datetime Root (builtin) type XSDDateTime Representation str","title":"Type: datetime"},{"location":"datamodel/types/Datetime/#type-datetime","text":"The combination of a date and time URI: linkml:Datetime Root (builtin) type XSDDateTime Representation str","title":"Type: datetime"},{"location":"datamodel/types/Decimal/","text":"Type: decimal A real number with arbitrary precision that conforms to the xsd:decimal specification URI: linkml:Decimal Root (builtin) type Decimal","title":"Type: decimal"},{"location":"datamodel/types/Decimal/#type-decimal","text":"A real number with arbitrary precision that conforms to the xsd:decimal specification URI: linkml:Decimal Root (builtin) type Decimal","title":"Type: decimal"},{"location":"datamodel/types/Double/","text":"Type: double A real number that conforms to the xsd:double specification URI: linkml:Double Root (builtin) type float","title":"Type: double"},{"location":"datamodel/types/Double/#type-double","text":"A real number that conforms to the xsd:double specification URI: linkml:Double Root (builtin) type float","title":"Type: double"},{"location":"datamodel/types/ElementReference/","text":"Type: ElementReference A pointer to an element in a datamodel URI: schemasheets:ElementReference Root (builtin) type str","title":"Type: ElementReference"},{"location":"datamodel/types/ElementReference/#type-elementreference","text":"A pointer to an element in a datamodel URI: schemasheets:ElementReference Root (builtin) type str","title":"Type: ElementReference"},{"location":"datamodel/types/Float/","text":"Type: float A real number that conforms to the xsd:float specification URI: linkml:Float Root (builtin) type float","title":"Type: float"},{"location":"datamodel/types/Float/#type-float","text":"A real number that conforms to the xsd:float specification URI: linkml:Float Root (builtin) type float","title":"Type: float"},{"location":"datamodel/types/Integer/","text":"Type: integer An integer URI: linkml:Integer Root (builtin) type int","title":"Type: integer"},{"location":"datamodel/types/Integer/#type-integer","text":"An integer URI: linkml:Integer Root (builtin) type int","title":"Type: integer"},{"location":"datamodel/types/Ncname/","text":"Type: ncname Prefix part of CURIE URI: linkml:Ncname Root (builtin) type NCName Representation str","title":"Type: ncname"},{"location":"datamodel/types/Ncname/#type-ncname","text":"Prefix part of CURIE URI: linkml:Ncname Root (builtin) type NCName Representation str","title":"Type: ncname"},{"location":"datamodel/types/Nodeidentifier/","text":"Type: nodeidentifier A URI, CURIE or BNODE that represents a node in a model. URI: linkml:Nodeidentifier Root (builtin) type NodeIdentifier Representation str","title":"Type: nodeidentifier"},{"location":"datamodel/types/Nodeidentifier/#type-nodeidentifier","text":"A URI, CURIE or BNODE that represents a node in a model. URI: linkml:Nodeidentifier Root (builtin) type NodeIdentifier Representation str","title":"Type: nodeidentifier"},{"location":"datamodel/types/Objectidentifier/","text":"Type: objectidentifier A URI or CURIE that represents an object in the model. URI: linkml:Objectidentifier Root (builtin) type ElementIdentifier Representation str Other properties Comments: Used for inheritence and type checking","title":"Type: objectidentifier"},{"location":"datamodel/types/Objectidentifier/#type-objectidentifier","text":"A URI or CURIE that represents an object in the model. URI: linkml:Objectidentifier Root (builtin) type ElementIdentifier Representation str","title":"Type: objectidentifier"},{"location":"datamodel/types/Objectidentifier/#other-properties","text":"Comments: Used for inheritence and type checking","title":"Other properties"},{"location":"datamodel/types/String/","text":"Type: string A character string URI: linkml:String Root (builtin) type str","title":"Type: string"},{"location":"datamodel/types/String/#type-string","text":"A character string URI: linkml:String Root (builtin) type str","title":"Type: string"},{"location":"datamodel/types/Time/","text":"Type: time A time object represents a (local) time of day, independent of any particular day URI: linkml:Time Root (builtin) type XSDTime Representation str","title":"Type: time"},{"location":"datamodel/types/Time/#type-time","text":"A time object represents a (local) time of day, independent of any particular day URI: linkml:Time Root (builtin) type XSDTime Representation str","title":"Type: time"},{"location":"datamodel/types/Uri/","text":"Type: uri a complete URI URI: linkml:Uri Root (builtin) type URI Representation str","title":"Type: uri"},{"location":"datamodel/types/Uri/#type-uri","text":"a complete URI URI: linkml:Uri Root (builtin) type URI Representation str","title":"Type: uri"},{"location":"datamodel/types/Uriorcurie/","text":"Type: uriorcurie a URI or a CURIE URI: linkml:Uriorcurie Root (builtin) type URIorCURIE Representation str","title":"Type: uriorcurie"},{"location":"datamodel/types/Uriorcurie/#type-uriorcurie","text":"a URI or a CURIE URI: linkml:Uriorcurie Root (builtin) type URIorCURIE Representation str","title":"Type: uriorcurie"},{"location":"howto/data-dictionaries/","text":"Simple data dictionaries A data dictionary is a file (or collection of files) which unambiguously declares, defines and annotates all the variables collected in a project and associated to a dataset (_definition: FAIR cookbook ). Schemasheets is an idea framework for managing a data dictionary. Example Data Dictionary The FAIR Cookbook provides an example of a data dictionary for tracking various aspects of a research subject or model organism, including: subject_id species strain (for model organisms) age + age unit etc See Example . Let's start by copying this directly into a google sheet. You can see this on the v1 tab of this sheet File Name Variable Name Variable Label Variable Ontology ID or RDFtype Variable ID Source Variable Statistical Type Variable Data Type Variable Size Max Allowed Value Min Allowed Value Regex Allowed Value Shorthands Allowed Value Descriptions Computed Value Unique (alone) Unique (Combined with) Required Collection Form Name Comments 1_Subjects.txt SUBJECT_ID Subject number https://schema.org/identifier https://schema.org categorical variable integer Y Y FORM 1 1_Subjects.txt SPECIES Species name https://schema.org/name https://schema.org categorical variable string FORM 1 1_Subjects.txt STRAIN Strain TODO substitute broken link https://bioschemas.org/profiles/Taxon/0.6-RELEASE/identifier https://schemas.org/ categorical variable string http://purl.obolibrary.org/obo/NCBITaxon_40674 FORM 1 1_Subjects.txt AGE Age at study initiation https://bioschemas.org/types/BioSample/0.1-RELEASE-2019_06_19 https://bioschemas.org/ continuous variable integer Y FORM 1 1_Subjects.txt AGE_UNIT Age unit http://purl.obolibrary.org/obo/UO_0000003 http://purl.obolibrary.org/obo/uo categorial variable string Y FORM 1 1_Subjects.txt SEX Sex https://schema.org/gender https://schema.org categorical variable enum M;F M=male;F=female FORM 1 Adding a descriptor row Our first task is to add a descriptor row that describes how each column heading maps to a LinkML metamodel element. Here we will tackle this incrementally, starting with the first 3 columns, we will map to: [class][https://w3id.org/linkml/ClassDefinition] [slot][https://w3id.org/linkml/SlotDefinition] [title][https://w3id.org/linkml/title] The table now looks like this: File Name Variable Name Variable Label > class slot title 1_Subjects.txt SUBJECT_ID Subject number 1_Subjects.txt SPECIES Species name 1_Subjects.txt STRAIN Strain 1_Subjects.txt AGE Age at study initiation 1_Subjects.txt AGE_UNIT Age unit 1_Subjects.txt SEX Sex 1_Subjects.txt SOMEDATE Date of acquiring subject 1_Subjects.txt HEMOGLOBIN Hematology: Hemoglobin 1_Subjects.txt HEMOGLOBIN_UNIT Hemoglobin unit 1_Subjects.txt HEIGHT Body size 1_Subjects.txt HEIGHT_UNIT Body size unit 1_Subjects.txt WEIGHT Body weight 1_Subjects.txt WEIGHT_UNIT Body weight unit 1_Subjects.txt BMI Body mass index 1_Subjects.txt LAB Laboratory 2_Samples.txt SAMPLE_ID Sample ID 2_Samples.txt SAMPLE_SITE Sample collection site 2_Samples.txt ANALYTE_TYPE Type of analysis 2_Samples.txt GENOTYPING_CENTER GENOTYPING_CENTER 2_Samples.txt SEQUENCING_CENTER SEQUENCING_CENTER 3_SampleMapping.txt SUBJECT_ID Subject number 3_SampleMapping.txt SAMPLE_ID Sample ID Our choice of how to map the first column is a bit odd, and reflects a slight mismatch between schemasheets/LinkML, which aims to describe a data model that can be used for multiple instantiations of the same format and a data dictionary that is oriented around describing a single distribution . Here we are implicitly creating classes/records like \"1_Subjects.txt\" which doesn't really conform to standard class naming conventions in LinkML. Later we will explore rewriting these with names like \"Subject\", \"Sample\", and \"SampleMapping\" TODO For the second column, the choice of ALL-CAPS for slot name also goes against standard naming conventions, but this doesn't really matter so much, and the title (col 3) is the string that should be used in user-facing applications like Data Harmonizer. Modifications We modified the minimum and maximum values which were specified using commas instead of periods for decimal notation The \"regex\" field had a value YYYY-MM-DD, but this isn't an actual regex This framework allows you to represent complex relation-style schemas using spreadsheets/TSVs. But it also allows for representation of simple \"data dictionaries\" or \"minimal information lists\". These can be thought of as \"wide tables\", e.g. representing individual observations or observable units such as persons or samples. TODO","title":"Simple data dictionaries"},{"location":"howto/data-dictionaries/#simple-data-dictionaries","text":"A data dictionary is a file (or collection of files) which unambiguously declares, defines and annotates all the variables collected in a project and associated to a dataset (_definition: FAIR cookbook ). Schemasheets is an idea framework for managing a data dictionary.","title":"Simple data dictionaries"},{"location":"howto/data-dictionaries/#example-data-dictionary","text":"The FAIR Cookbook provides an example of a data dictionary for tracking various aspects of a research subject or model organism, including: subject_id species strain (for model organisms) age + age unit etc See Example . Let's start by copying this directly into a google sheet. You can see this on the v1 tab of this sheet File Name Variable Name Variable Label Variable Ontology ID or RDFtype Variable ID Source Variable Statistical Type Variable Data Type Variable Size Max Allowed Value Min Allowed Value Regex Allowed Value Shorthands Allowed Value Descriptions Computed Value Unique (alone) Unique (Combined with) Required Collection Form Name Comments 1_Subjects.txt SUBJECT_ID Subject number https://schema.org/identifier https://schema.org categorical variable integer Y Y FORM 1 1_Subjects.txt SPECIES Species name https://schema.org/name https://schema.org categorical variable string FORM 1 1_Subjects.txt STRAIN Strain TODO substitute broken link https://bioschemas.org/profiles/Taxon/0.6-RELEASE/identifier https://schemas.org/ categorical variable string http://purl.obolibrary.org/obo/NCBITaxon_40674 FORM 1 1_Subjects.txt AGE Age at study initiation https://bioschemas.org/types/BioSample/0.1-RELEASE-2019_06_19 https://bioschemas.org/ continuous variable integer Y FORM 1 1_Subjects.txt AGE_UNIT Age unit http://purl.obolibrary.org/obo/UO_0000003 http://purl.obolibrary.org/obo/uo categorial variable string Y FORM 1 1_Subjects.txt SEX Sex https://schema.org/gender https://schema.org categorical variable enum M;F M=male;F=female FORM 1","title":"Example Data Dictionary"},{"location":"howto/data-dictionaries/#adding-a-descriptor-row","text":"Our first task is to add a descriptor row that describes how each column heading maps to a LinkML metamodel element. Here we will tackle this incrementally, starting with the first 3 columns, we will map to: [class][https://w3id.org/linkml/ClassDefinition] [slot][https://w3id.org/linkml/SlotDefinition] [title][https://w3id.org/linkml/title] The table now looks like this: File Name Variable Name Variable Label > class slot title 1_Subjects.txt SUBJECT_ID Subject number 1_Subjects.txt SPECIES Species name 1_Subjects.txt STRAIN Strain 1_Subjects.txt AGE Age at study initiation 1_Subjects.txt AGE_UNIT Age unit 1_Subjects.txt SEX Sex 1_Subjects.txt SOMEDATE Date of acquiring subject 1_Subjects.txt HEMOGLOBIN Hematology: Hemoglobin 1_Subjects.txt HEMOGLOBIN_UNIT Hemoglobin unit 1_Subjects.txt HEIGHT Body size 1_Subjects.txt HEIGHT_UNIT Body size unit 1_Subjects.txt WEIGHT Body weight 1_Subjects.txt WEIGHT_UNIT Body weight unit 1_Subjects.txt BMI Body mass index 1_Subjects.txt LAB Laboratory 2_Samples.txt SAMPLE_ID Sample ID 2_Samples.txt SAMPLE_SITE Sample collection site 2_Samples.txt ANALYTE_TYPE Type of analysis 2_Samples.txt GENOTYPING_CENTER GENOTYPING_CENTER 2_Samples.txt SEQUENCING_CENTER SEQUENCING_CENTER 3_SampleMapping.txt SUBJECT_ID Subject number 3_SampleMapping.txt SAMPLE_ID Sample ID Our choice of how to map the first column is a bit odd, and reflects a slight mismatch between schemasheets/LinkML, which aims to describe a data model that can be used for multiple instantiations of the same format and a data dictionary that is oriented around describing a single distribution . Here we are implicitly creating classes/records like \"1_Subjects.txt\" which doesn't really conform to standard class naming conventions in LinkML. Later we will explore rewriting these with names like \"Subject\", \"Sample\", and \"SampleMapping\" TODO For the second column, the choice of ALL-CAPS for slot name also goes against standard naming conventions, but this doesn't really matter so much, and the title (col 3) is the string that should be used in user-facing applications like Data Harmonizer.","title":"Adding a descriptor row"},{"location":"howto/data-dictionaries/#modifications","text":"We modified the minimum and maximum values which were specified using commas instead of periods for decimal notation The \"regex\" field had a value YYYY-MM-DD, but this isn't an actual regex This framework allows you to represent complex relation-style schemas using spreadsheets/TSVs. But it also allows for representation of simple \"data dictionaries\" or \"minimal information lists\". These can be thought of as \"wide tables\", e.g. representing individual observations or observable units such as persons or samples. TODO","title":"Modifications"},{"location":"howto/excel/","text":"Working with Excel spreadsheets Currently there no direct support for working with Excel formats. You must export to TSV format prior to running `sheets2linkml' We are hoping to provide more extensive support for Excel starting in 2023. Tips schemasheets will not catch errors introduced by Excel, including gene names turned into dates be sure to save as TSV, tabs are the default delimiter in schemasheets avoid using non UTF-8 characters avoid using color, font, etc We recommend maintain as .tsv (not .xlsx) tracked in GitHub","title":"Working with Excel"},{"location":"howto/excel/#working-with-excel-spreadsheets","text":"Currently there no direct support for working with Excel formats. You must export to TSV format prior to running `sheets2linkml' We are hoping to provide more extensive support for Excel starting in 2023.","title":"Working with Excel spreadsheets"},{"location":"howto/excel/#tips","text":"schemasheets will not catch errors introduced by Excel, including gene names turned into dates be sure to save as TSV, tabs are the default delimiter in schemasheets avoid using non UTF-8 characters avoid using color, font, etc We recommend maintain as .tsv (not .xlsx) tracked in GitHub","title":"Tips"},{"location":"howto/google-sheets/","text":"Working with Google sheets This tool takes as input a collection of sheets, which are stored as TSV files. You can make use of various ways of managing/organizing these: TSVs files maintained in GitHub Google sheets Excel spreadsheets SQLite databases Tips for each of these and for organizing your information are provided below Multiple sheets vs single sheets It is up to you whether you represent your schema as a single sheet or as multiple sheets However, if your schema includes a mixture of different element types, you may end up with a lot of null values if you have a single sheet. It can be more intuitive to \"normalize\" your schema description into different sheets: sheets for classes/slots sheets for enums sheets for types Currently schemasheets has no built in facilities for interacting directly with google sheets - it is up to you to both download and upload these TODO: scripts for merging/splitting sheets gsheets option For going from sheets to linkml, you can specify --gsheet-id , then each argument becomes the name of a sheet. This automatically downloads each sheet and dynamically transforms. E.g. sheets2linkml --gsheet-id 1wVoaiFg47aT9YWNeRfTZ8tYHN8s8PAuDx5i2HUcDpvQ personinfo types prefixes -o personinfo.yaml Note : due to a bug with google sheets API (see this Stack Overflow question ), this will not work if your sheet has floats/decimals in them. It's not clear if google will ever fix this. If you need decimals, then you should either manually download the sheet to TSV, or use COGS. COGS We recommend the COGS framework for working with google sheets cogs A common pattern is a single sheet document for a schema, with different sheets/tabs for different parts of the schema","title":"Working with Google Sheets"},{"location":"howto/google-sheets/#working-with-google-sheets","text":"This tool takes as input a collection of sheets, which are stored as TSV files. You can make use of various ways of managing/organizing these: TSVs files maintained in GitHub Google sheets Excel spreadsheets SQLite databases Tips for each of these and for organizing your information are provided below","title":"Working with Google sheets"},{"location":"howto/google-sheets/#multiple-sheets-vs-single-sheets","text":"It is up to you whether you represent your schema as a single sheet or as multiple sheets However, if your schema includes a mixture of different element types, you may end up with a lot of null values if you have a single sheet. It can be more intuitive to \"normalize\" your schema description into different sheets: sheets for classes/slots sheets for enums sheets for types Currently schemasheets has no built in facilities for interacting directly with google sheets - it is up to you to both download and upload these TODO: scripts for merging/splitting sheets","title":"Multiple sheets vs single sheets"},{"location":"howto/google-sheets/#gsheets-option","text":"For going from sheets to linkml, you can specify --gsheet-id , then each argument becomes the name of a sheet. This automatically downloads each sheet and dynamically transforms. E.g. sheets2linkml --gsheet-id 1wVoaiFg47aT9YWNeRfTZ8tYHN8s8PAuDx5i2HUcDpvQ personinfo types prefixes -o personinfo.yaml Note : due to a bug with google sheets API (see this Stack Overflow question ), this will not work if your sheet has floats/decimals in them. It's not clear if google will ever fix this. If you need decimals, then you should either manually download the sheet to TSV, or use COGS.","title":"gsheets option"},{"location":"howto/google-sheets/#cogs","text":"We recommend the COGS framework for working with google sheets cogs A common pattern is a single sheet document for a schema, with different sheets/tabs for different parts of the schema","title":"COGS"},{"location":"howto/sqlite/","text":"Working with SQLite TODO","title":"Working with SQLite"},{"location":"howto/sqlite/#working-with-sqlite","text":"TODO","title":"Working with SQLite"},{"location":"intro/basics/","text":"Basics Schemasheets allow you to write schemas to manage your data without writing any code. You keep the source for your schema as a spreadsheet (e.g. in google sheets), and convert to LinkML using sheets2linkml Example The following example shows a schema sheet for a schema that is focused around the concept of a Person. The rows in the sheet describe either classes or slots (fields) record field key multiplicity range desc schema.org > class slot identifier cardinality range description exact_mappings: {curie_prefix: sdo} - id yes 1 string any identifier identifier - description no 0..1 string a textual description description Person n/a n/a n/a a person,living or dead Person Person id yes 1 string identifier for a person identifier Person, Organization name no 1 string full name name Person age no 0..1 decimal age in years - Person gender no 0..1 decimal age in years - Person has medical history no 0..* MedicalEvent medical history - MedicalEvent n/a n/a n/a - - You can see this example as a google sheet, or as a file in GitHub: personinfo google sheet tests/input/personinfo.tsv equivalent file in github To convert this, assuming personinfo.tsv is in your current directory: sheets2linkml personinfo.tsv The sheet is structured as follows: Header Line The first line is a header line. You get to decide the column headers record field key multiplicity range desc schema.org Column Descriptors Subsequent lines starting with > are column descriptors these provide a way to interpret the columns descriptors can be drawn from the linkml vocabulary In the example above, there is a single row of descriptions: record field key multiplicity range desc schema.org > class slot identifier cardinality range description exact_mappings: {curie_prefix: sdo} Here the column named record maps to the LinkML element class, field to slot, and so on. The final column is an example of a complex mapping which we will get to later. Schema Elements Remaining rows are elements of your schema Each element gets its own row A row can represent a class (record, table), field (column), enumeration, or other element types Looking at the first three element rows, we can see the first two represent fields (slots), in particular a field called id which is an identifier, and a field called description record field key multiplicity range desc schema.org > class slot identifier cardinality range description exact_mappings: {curie_prefix: sdo} - id yes 1 string any identifier identifier - description no 0..1 string a textual description description Person n/a n/a n/a a person,living or dead Person The third element row represents a record (class) type - here, a Person Core Concepts The most basic schema concepts are classes and slots classes represent record types, similar to tables in a database or sheets in a spreadsheet slots represent fields, similar to columns in a database or spreadsheet These can be used in combination: If a class is provided, but a slot is not, then the row represents a class. If a slot is provided, but a class is not, then the row represents a slot (field) If both class and slot are provided, then the row represents the usage of a slot in the context of a class Looking at the first 4 element (non- > ) rows: record field key multiplicity range desc schema.org > class slot identifier cardinality range description exact_mappings: {curie_prefix: sdo} - id yes 1 string any identifier identifier - description no 0..1 string a textual description description Person n/a n/a n/a a person,living or dead Person Person id yes 1 string identifier for a person identifier The first two are slots, the third is a slot, and the fourth represents the slot id when used in the context of the Person class. To understand more about the concept of contextual slots, see Slot Usage Docs in the main LinkML guide. Other element types are: Enums, for enumerations Prefixes, for representing prefix maps Schemas, for schemas Types, for primitive datatypes See LinkML schemas for more information","title":"Basics"},{"location":"intro/basics/#basics","text":"Schemasheets allow you to write schemas to manage your data without writing any code. You keep the source for your schema as a spreadsheet (e.g. in google sheets), and convert to LinkML using sheets2linkml","title":"Basics"},{"location":"intro/basics/#example","text":"The following example shows a schema sheet for a schema that is focused around the concept of a Person. The rows in the sheet describe either classes or slots (fields) record field key multiplicity range desc schema.org > class slot identifier cardinality range description exact_mappings: {curie_prefix: sdo} - id yes 1 string any identifier identifier - description no 0..1 string a textual description description Person n/a n/a n/a a person,living or dead Person Person id yes 1 string identifier for a person identifier Person, Organization name no 1 string full name name Person age no 0..1 decimal age in years - Person gender no 0..1 decimal age in years - Person has medical history no 0..* MedicalEvent medical history - MedicalEvent n/a n/a n/a - - You can see this example as a google sheet, or as a file in GitHub: personinfo google sheet tests/input/personinfo.tsv equivalent file in github To convert this, assuming personinfo.tsv is in your current directory: sheets2linkml personinfo.tsv The sheet is structured as follows:","title":"Example"},{"location":"intro/basics/#header-line","text":"The first line is a header line. You get to decide the column headers record field key multiplicity range desc schema.org","title":"Header Line"},{"location":"intro/basics/#column-descriptors","text":"Subsequent lines starting with > are column descriptors these provide a way to interpret the columns descriptors can be drawn from the linkml vocabulary In the example above, there is a single row of descriptions: record field key multiplicity range desc schema.org > class slot identifier cardinality range description exact_mappings: {curie_prefix: sdo} Here the column named record maps to the LinkML element class, field to slot, and so on. The final column is an example of a complex mapping which we will get to later.","title":"Column Descriptors"},{"location":"intro/basics/#schema-elements","text":"Remaining rows are elements of your schema Each element gets its own row A row can represent a class (record, table), field (column), enumeration, or other element types Looking at the first three element rows, we can see the first two represent fields (slots), in particular a field called id which is an identifier, and a field called description record field key multiplicity range desc schema.org > class slot identifier cardinality range description exact_mappings: {curie_prefix: sdo} - id yes 1 string any identifier identifier - description no 0..1 string a textual description description Person n/a n/a n/a a person,living or dead Person The third element row represents a record (class) type - here, a Person","title":"Schema Elements"},{"location":"intro/basics/#core-concepts","text":"The most basic schema concepts are classes and slots classes represent record types, similar to tables in a database or sheets in a spreadsheet slots represent fields, similar to columns in a database or spreadsheet These can be used in combination: If a class is provided, but a slot is not, then the row represents a class. If a slot is provided, but a class is not, then the row represents a slot (field) If both class and slot are provided, then the row represents the usage of a slot in the context of a class Looking at the first 4 element (non- > ) rows: record field key multiplicity range desc schema.org > class slot identifier cardinality range description exact_mappings: {curie_prefix: sdo} - id yes 1 string any identifier identifier - description no 0..1 string a textual description description Person n/a n/a n/a a person,living or dead Person Person id yes 1 string identifier for a person identifier The first two are slots, the third is a slot, and the fourth represents the slot id when used in the context of the Person class. To understand more about the concept of contextual slots, see Slot Usage Docs in the main LinkML guide. Other element types are: Enums, for enumerations Prefixes, for representing prefix maps Schemas, for schemas Types, for primitive datatypes See LinkML schemas for more information","title":"Core Concepts"},{"location":"intro/cardinality/","text":"Specifying cardinality About Cardinality refers to how many values a particular field is required or allowed to have Example In the following schema, the column heading \"multiplicity\" is mapped to \"cardinality\": record field key multiplicity range desc schema.org > class slot identifier cardinality range description exact_mappings: {curie_prefix: sdo} - id yes 1 string any identifier identifier - description no 0..1 string a textual description description Person has medical history no 0..* MedicalEvent medical history - Here, the cardinalities state: there must be exactly one id there may be a description zero to many medical history events How it works See configschema.yaml for all possible vocabularies, these include: UML strings, e.g. '0..1' text strings matching the cardinality vocabulary, e.g. 'zero to one' codes used in cardinality vocabulary, e.g. O, M, ... The vocabulary maps to underlying LinkML primitives: required multivalued recommended Cardinality Vocabulary Cardinality vocabulary yaml","title":"Cardinality"},{"location":"intro/cardinality/#specifying-cardinality","text":"","title":"Specifying cardinality"},{"location":"intro/cardinality/#about","text":"Cardinality refers to how many values a particular field is required or allowed to have","title":"About"},{"location":"intro/cardinality/#example","text":"In the following schema, the column heading \"multiplicity\" is mapped to \"cardinality\": record field key multiplicity range desc schema.org > class slot identifier cardinality range description exact_mappings: {curie_prefix: sdo} - id yes 1 string any identifier identifier - description no 0..1 string a textual description description Person has medical history no 0..* MedicalEvent medical history - Here, the cardinalities state: there must be exactly one id there may be a description zero to many medical history events","title":"Example"},{"location":"intro/cardinality/#how-it-works","text":"See configschema.yaml for all possible vocabularies, these include: UML strings, e.g. '0..1' text strings matching the cardinality vocabulary, e.g. 'zero to one' codes used in cardinality vocabulary, e.g. O, M, ... The vocabulary maps to underlying LinkML primitives: required multivalued recommended","title":"How it works"},{"location":"intro/cardinality/#cardinality-vocabulary","text":"Cardinality vocabulary yaml","title":"Cardinality Vocabulary"},{"location":"intro/converting/","text":"Generating schemas Although you can use schemasheets without writing any code, some technical expertise is still required to run scripts to generate schema artefacts from sheets, and to use these. Generating a Project Assuming your schema is arranged as a set of sheets (TSV files) in the src folder: sheets2project -d . src/*.tsv This will generate individual folders for jsonschema, shacl, ... as well as a website that can be easily hosted on github. Generating a LinkML schema To create only LinkML yaml: sheets2linkml -o my.yaml src/*.tsv","title":"Converting"},{"location":"intro/converting/#generating-schemas","text":"Although you can use schemasheets without writing any code, some technical expertise is still required to run scripts to generate schema artefacts from sheets, and to use these.","title":"Generating schemas"},{"location":"intro/converting/#generating-a-project","text":"Assuming your schema is arranged as a set of sheets (TSV files) in the src folder: sheets2project -d . src/*.tsv This will generate individual folders for jsonschema, shacl, ... as well as a website that can be easily hosted on github.","title":"Generating a Project"},{"location":"intro/converting/#generating-a-linkml-schema","text":"To create only LinkML yaml: sheets2linkml -o my.yaml src/*.tsv","title":"Generating a LinkML schema"},{"location":"intro/enums/","text":"Enums About Enumerations can be thought of as \"dropdowns\" or picklists in data entry forms. Minimally, the enum is a predefined set of strings. These strings can optionally be provided with more metadata, such as descriptions or assignment of controlled vocabulary/ontology terms How it works Two descriptors are provided for enumerations: enum permissible_value These can be used in combination: If enum is provided, and permissible_value is not, then the row represents an enumeration If both enum and permissible_value are provided, the row represents a particular enum value Example The following example includes two enums, each with a few permissible values ValueSet Value Mapping Desc > enum permissible_value meaning description FamilialRelationshipType - - familial relationships FamilialRelationshipType SIBLING_OF KIN:007 share the same parent FamilialRelationshipType PARENT_OF KIN:003 biological parent FamilialRelationshipType CHILD_OF KIN:032 inverse of parent GenderType - - gender GenderType nonbinary man GSSO:009254 - GenderType nonbinary woman GSSO:009253 - ... ... ... - enums google sheet Although optionable recommend you provide descriptions of both the enumeration and the meaning descriptor which maps the value to a vocabulary or ontology term. Note that prefixes should be separately declared. In the examples here, we are using two different ontologies. More info For more on enumerations, see LinkML Schema Guide and the the linkml tutorial","title":"Enums"},{"location":"intro/enums/#enums","text":"","title":"Enums"},{"location":"intro/enums/#about","text":"Enumerations can be thought of as \"dropdowns\" or picklists in data entry forms. Minimally, the enum is a predefined set of strings. These strings can optionally be provided with more metadata, such as descriptions or assignment of controlled vocabulary/ontology terms","title":"About"},{"location":"intro/enums/#how-it-works","text":"Two descriptors are provided for enumerations: enum permissible_value These can be used in combination: If enum is provided, and permissible_value is not, then the row represents an enumeration If both enum and permissible_value are provided, the row represents a particular enum value","title":"How it works"},{"location":"intro/enums/#example","text":"The following example includes two enums, each with a few permissible values ValueSet Value Mapping Desc > enum permissible_value meaning description FamilialRelationshipType - - familial relationships FamilialRelationshipType SIBLING_OF KIN:007 share the same parent FamilialRelationshipType PARENT_OF KIN:003 biological parent FamilialRelationshipType CHILD_OF KIN:032 inverse of parent GenderType - - gender GenderType nonbinary man GSSO:009254 - GenderType nonbinary woman GSSO:009253 - ... ... ... - enums google sheet Although optionable recommend you provide descriptions of both the enumeration and the meaning descriptor which maps the value to a vocabulary or ontology term. Note that prefixes should be separately declared. In the examples here, we are using two different ontologies.","title":"Example"},{"location":"intro/enums/#more-info","text":"For more on enumerations, see LinkML Schema Guide and the the linkml tutorial","title":"More info"},{"location":"intro/export/","text":"Exporting a schema to schemasheets Use Case Sometimes you might want to export from an existing LinkML schema to schemasheets - for example to migrate the source of some or part of a schema to sheet-based editing. The sheets2linkml command will convert schemasheet(s) to a LinkML schema The reverse operation linkml2sheets will convert a LinkML schema to schemasheets Status THIS COMMAND IS ONLY PARTIALLY IMPLEMENTED -- not all parts of the specification are considered. However, you may still find this useful for \"bootstrapping\" schema sheets Usage Type linkml2sheets --help to get complete help Broadly there are two usage scenarios: when you have a single sheet when your schema is mapped to multiple sheets (e.g. enums and slots in different sheets) In both cases you need two inputs A linkml schema, specified in yaml One or more schemasheets that serve as the specification these do not need to have any data they do need the columns used and column descriptors Single-sheet usage Here you pass a single TSV specification on the command line You can use the --output ( -o ) option to write output to a single sheet file. Or omit this to write on stdout. Multi-sheet usage Here you multiple TSV specifications on the command line You must use the --directory ( -d ) option to specify which directory the files are written to. The filenames will be the same. So for example, if you had a folder: sheets/ enums.tsv slots.tsv where: each tsv contains minimally the column specifications, you pass in sheets/*tsv as input you pass --directory output Then you will generate a folder: output/ enums.tsv slots.tsv the headers will be the same as the TSVs in the input, but it will include \"data\" rows, where each row is a matching schema element the input and output directory can be identical, but you will need to pass in --overwrite to explicitly overwrite, this guards against accidental overwrites. Converting between two different schemasheet specs schemasheets allows custom sheet formats that map to the LinkML standard. you can use the combination of sheets2linkml and linkml2sheets to convert betweeen two sheet specifications. For example, let's say for schema1.tsv, you use a spreadsheet with the following headers: record: > class field: > slot cardinality: > cardinality info: > description and for schema2.tsv you have: table: > class attribute: > slot required: > required multivalued: > multivalued description: > description (here each list element is a column, and the part after the > is the 2nd row) If you do: sheets2linkml schema1.tsv > schema1.yaml linkml2sheets -s schema1.yaml schema2.tsv > schema2_full.tsv then this will effectively map schema1.tsv onto the format for schema2.tsv. And you can swap the arguments to go in the reverse direction.","title":"Exporting to schemasheets"},{"location":"intro/export/#exporting-a-schema-to-schemasheets","text":"","title":"Exporting a schema to schemasheets"},{"location":"intro/export/#use-case","text":"Sometimes you might want to export from an existing LinkML schema to schemasheets - for example to migrate the source of some or part of a schema to sheet-based editing. The sheets2linkml command will convert schemasheet(s) to a LinkML schema The reverse operation linkml2sheets will convert a LinkML schema to schemasheets","title":"Use Case"},{"location":"intro/export/#status","text":"THIS COMMAND IS ONLY PARTIALLY IMPLEMENTED -- not all parts of the specification are considered. However, you may still find this useful for \"bootstrapping\" schema sheets","title":"Status"},{"location":"intro/export/#usage","text":"Type linkml2sheets --help to get complete help Broadly there are two usage scenarios: when you have a single sheet when your schema is mapped to multiple sheets (e.g. enums and slots in different sheets) In both cases you need two inputs A linkml schema, specified in yaml One or more schemasheets that serve as the specification these do not need to have any data they do need the columns used and column descriptors","title":"Usage"},{"location":"intro/export/#single-sheet-usage","text":"Here you pass a single TSV specification on the command line You can use the --output ( -o ) option to write output to a single sheet file. Or omit this to write on stdout.","title":"Single-sheet usage"},{"location":"intro/export/#multi-sheet-usage","text":"Here you multiple TSV specifications on the command line You must use the --directory ( -d ) option to specify which directory the files are written to. The filenames will be the same. So for example, if you had a folder: sheets/ enums.tsv slots.tsv where: each tsv contains minimally the column specifications, you pass in sheets/*tsv as input you pass --directory output Then you will generate a folder: output/ enums.tsv slots.tsv the headers will be the same as the TSVs in the input, but it will include \"data\" rows, where each row is a matching schema element the input and output directory can be identical, but you will need to pass in --overwrite to explicitly overwrite, this guards against accidental overwrites.","title":"Multi-sheet usage"},{"location":"intro/export/#converting-between-two-different-schemasheet-specs","text":"schemasheets allows custom sheet formats that map to the LinkML standard. you can use the combination of sheets2linkml and linkml2sheets to convert betweeen two sheet specifications. For example, let's say for schema1.tsv, you use a spreadsheet with the following headers: record: > class field: > slot cardinality: > cardinality info: > description and for schema2.tsv you have: table: > class attribute: > slot required: > required multivalued: > multivalued description: > description (here each list element is a column, and the part after the > is the 2nd row) If you do: sheets2linkml schema1.tsv > schema1.yaml linkml2sheets -s schema1.yaml schema2.tsv > schema2_full.tsv then this will effectively map schema1.tsv onto the format for schema2.tsv. And you can swap the arguments to go in the reverse direction.","title":"Converting between two different schemasheet specs"},{"location":"intro/grids/","text":"Overriding fields Use Case Previously we saw example of how to define fields (slots). The characteristics of these fields remained the same even if they were used with different classes If you have a large number of fields/columns, with varying applicability/cardinality across different classes, it can be convenient to specify this as a grid. Example An example is a minimal information standard that includes different packages or checklists, e.g. MIxS. Here we may want a slot such as \"soil sample depth\" to be mandatory for soil samples, optional for other kinds of samples. Example sheet: term title desc mi_patient mi_mod mi_terrestrial mi_marine mi_extraterrestrial > slot title description cardinality cardinality cardinality cardinality cardinality > applies_to_class: MI patient applies_to_class: MI model organism applies_to_class: MI terrestrial sample applies_to_class: MI marine sample applies_to_class: MI extraterrestrial sample id unique identifier a unique id M M M M M alt_ids other identifiers any other identifiers O O O O O body_site body site location where sample is taken from M R - - - disease disease status disease the patient had M O - - - age age age M R - - - depth depth depth in ground or water - - R R R alt altitude height above sea level R R R salinity salinity salinity R R R porosity porosity porosity location location location on earth astronomical_body astronomical body planet or other astronomical object where sample was collected M data dictionary google sheet Here the applies_to_class descriptor indicates that the column value for the slot indicated in the row is interpreted as slot usage for that class. More information See slot usage","title":"Grids"},{"location":"intro/grids/#overriding-fields","text":"","title":"Overriding fields"},{"location":"intro/grids/#use-case","text":"Previously we saw example of how to define fields (slots). The characteristics of these fields remained the same even if they were used with different classes If you have a large number of fields/columns, with varying applicability/cardinality across different classes, it can be convenient to specify this as a grid.","title":"Use Case"},{"location":"intro/grids/#example","text":"An example is a minimal information standard that includes different packages or checklists, e.g. MIxS. Here we may want a slot such as \"soil sample depth\" to be mandatory for soil samples, optional for other kinds of samples. Example sheet: term title desc mi_patient mi_mod mi_terrestrial mi_marine mi_extraterrestrial > slot title description cardinality cardinality cardinality cardinality cardinality > applies_to_class: MI patient applies_to_class: MI model organism applies_to_class: MI terrestrial sample applies_to_class: MI marine sample applies_to_class: MI extraterrestrial sample id unique identifier a unique id M M M M M alt_ids other identifiers any other identifiers O O O O O body_site body site location where sample is taken from M R - - - disease disease status disease the patient had M O - - - age age age M R - - - depth depth depth in ground or water - - R R R alt altitude height above sea level R R R salinity salinity salinity R R R porosity porosity porosity location location location on earth astronomical_body astronomical body planet or other astronomical object where sample was collected M data dictionary google sheet Here the applies_to_class descriptor indicates that the column value for the slot indicated in the row is interpreted as slot usage for that class.","title":"Example"},{"location":"intro/grids/#more-information","text":"See slot usage","title":"More information"},{"location":"intro/mixed-sheets/","text":"Mixed sheets In all of the examples above, distinct descriptors are used for class names, slot names, type names, enum names, etc An alternative pattern is to mix element types in a single sheet, indicate the name of the element using name and the type using metatype . For example: type item applies to key multiplicity range parents desc schema.org wikidata belongs status notes > metatype name class identifier cardinality range is_a description exact_mappings: {curie_prefix: sdo} exact_mappings: {curie_prefix: wikidata} in_subset status ignore > vmap: {C: class, F: slot} > curie_prefix: wikidata vmap: {T: testing, R: release} F id yes 1 string any identifier identifier F name Person, Organization no 1 string full name name F description no 0..1 string a textual description description F age Person no 0..1 decimal age in years F gender Person no 0..1 decimal age in years F has medical history Person no 0..* MedicalEvent medical history T C Person a person,living or dead Person Q215627 R C Event grouping class for events Q1656682 a R C MedicalEvent Event a medical encounter b T C ForProfit Organization C NonProfit Organization Q163740 foo personinfo with tyoes","title":"Mixed sheets"},{"location":"intro/mixed-sheets/#mixed-sheets","text":"In all of the examples above, distinct descriptors are used for class names, slot names, type names, enum names, etc An alternative pattern is to mix element types in a single sheet, indicate the name of the element using name and the type using metatype . For example: type item applies to key multiplicity range parents desc schema.org wikidata belongs status notes > metatype name class identifier cardinality range is_a description exact_mappings: {curie_prefix: sdo} exact_mappings: {curie_prefix: wikidata} in_subset status ignore > vmap: {C: class, F: slot} > curie_prefix: wikidata vmap: {T: testing, R: release} F id yes 1 string any identifier identifier F name Person, Organization no 1 string full name name F description no 0..1 string a textual description description F age Person no 0..1 decimal age in years F gender Person no 0..1 decimal age in years F has medical history Person no 0..* MedicalEvent medical history T C Person a person,living or dead Person Q215627 R C Event grouping class for events Q1656682 a R C MedicalEvent Event a medical encounter b T C ForProfit Organization C NonProfit Organization Q163740 foo personinfo with tyoes","title":"Mixed sheets"},{"location":"intro/prefixes/","text":"Prefixes If you specify a column descriptor of prefix , then rows with that column populated will represent prefixes. The prefix expansion is specified using prefix_reference Example prefix URI > prefix prefix_reference sdo http://schema.org/ personinfo https://w3id.org/linkml/examples/personinfo/ famrel https://example.org/FamilialRelations# GSSO http://purl.obolibrary.org/obo/GSSO_ See: the prefixes tab on the example google sheet tests/input/prefixes.tsv equivalent file in github Recommendations Although prefixes can be combined into one sheet, we recommend you specify prefixes in their own sheet. Automatic prefixes If prefixes are not provided, and you do not specify --no-repair then prefixes will be inferred using bioregistry , provided you use common, standard prefixes.","title":"Prefixes"},{"location":"intro/prefixes/#prefixes","text":"If you specify a column descriptor of prefix , then rows with that column populated will represent prefixes. The prefix expansion is specified using prefix_reference","title":"Prefixes"},{"location":"intro/prefixes/#example","text":"prefix URI > prefix prefix_reference sdo http://schema.org/ personinfo https://w3id.org/linkml/examples/personinfo/ famrel https://example.org/FamilialRelations# GSSO http://purl.obolibrary.org/obo/GSSO_ See: the prefixes tab on the example google sheet tests/input/prefixes.tsv equivalent file in github","title":"Example"},{"location":"intro/prefixes/#recommendations","text":"Although prefixes can be combined into one sheet, we recommend you specify prefixes in their own sheet.","title":"Recommendations"},{"location":"intro/prefixes/#automatic-prefixes","text":"If prefixes are not provided, and you do not specify --no-repair then prefixes will be inferred using bioregistry , provided you use common, standard prefixes.","title":"Automatic prefixes"},{"location":"intro/schema-metadata/","text":"Schema-level metadata If you specify a column descriptor of schema , then rows with that column populated will represent schemas. Example: Schema uri Desc Schema Prefix > schema id description default_prefix PersonInfo https://w3id.org/linkml/examples/personinfo Information about people, based on schema.org personinfo The list of potential descriptors for a schema can be found by consulting SchemaDefinition in the LinkML metamodel. Both id and name are required, these will be auto-filled if you don't fill this in. Populating the fields description and license is strongly encouraged. Currently multiple schemas are not supported, we recommend providing a single-row sheet for schema metadata","title":"Schema-level metadata"},{"location":"intro/schema-metadata/#schema-level-metadata","text":"If you specify a column descriptor of schema , then rows with that column populated will represent schemas. Example: Schema uri Desc Schema Prefix > schema id description default_prefix PersonInfo https://w3id.org/linkml/examples/personinfo Information about people, based on schema.org personinfo The list of potential descriptors for a schema can be found by consulting SchemaDefinition in the LinkML metamodel. Both id and name are required, these will be auto-filled if you don't fill this in. Populating the fields description and license is strongly encouraged. Currently multiple schemas are not supported, we recommend providing a single-row sheet for schema metadata","title":"Schema-level metadata"}]}