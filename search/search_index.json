{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Schemasheets Create a data dictionary / schema for your data using simple spreadsheets - no coding required. About Author your schema as a google sheet or excel spreadsheet Generate schemas : LinkML SHACL and ShEx JSON-Schema SQL DDL OWL Get tooling for free: Data validators Python bindings Create a website for your schema Examples See the test google sheets for examples See also the examples folder which has an end-to-end example Audience This tool is aimed at data modelers, curators, wrangers, and creators of standards and datamodels. It is aimed at people who prefer to develop these standards using spreadsheet tools over more developer-centric tooling. Using schemasheets you can develop your standard using google sheets, excel or any other table-editing tool. A variety of tooling is constructed automatically from this, no coding required. Future Developments Schemasheets was released at the beginning of 2022. It is not yet production software, and some parts may not be stable. We hope to harden parts of the toolchain, and also add more features that make it easier for non-technical people to use, include: Web based tooling for managing schemas Integration of existing LinkML tools, such as automated schema inference and mapping","title":"About"},{"location":"#schemasheets","text":"Create a data dictionary / schema for your data using simple spreadsheets - no coding required.","title":"Schemasheets"},{"location":"#about","text":"Author your schema as a google sheet or excel spreadsheet Generate schemas : LinkML SHACL and ShEx JSON-Schema SQL DDL OWL Get tooling for free: Data validators Python bindings Create a website for your schema","title":"About"},{"location":"#examples","text":"See the test google sheets for examples See also the examples folder which has an end-to-end example","title":"Examples"},{"location":"#audience","text":"This tool is aimed at data modelers, curators, wrangers, and creators of standards and datamodels. It is aimed at people who prefer to develop these standards using spreadsheet tools over more developer-centric tooling. Using schemasheets you can develop your standard using google sheets, excel or any other table-editing tool. A variety of tooling is constructed automatically from this, no coding required.","title":"Audience"},{"location":"#future-developments","text":"Schemasheets was released at the beginning of 2022. It is not yet production software, and some parts may not be stable. We hope to harden parts of the toolchain, and also add more features that make it easier for non-technical people to use, include: Web based tooling for managing schemas Integration of existing LinkML tools, such as automated schema inference and mapping","title":"Future Developments"},{"location":"install/","text":"Installation Requirements Python 3.7 or higher is required. Install Schemasheets Install in the standard way from PyPi: pip install schemasheets Docker Docker containers will be provided in future","title":"Installation"},{"location":"install/#installation","text":"","title":"Installation"},{"location":"install/#requirements","text":"Python 3.7 or higher is required.","title":"Requirements"},{"location":"install/#install-schemasheets","text":"Install in the standard way from PyPi: pip install schemasheets","title":"Install Schemasheets"},{"location":"install/#docker","text":"Docker containers will be provided in future","title":"Docker"},{"location":"specification/","text":"Specification (in progress) The following is an outline. Please refer to the above examples for elucidation. Sheet Structure A sheet is conceptualized as a collection of rows, which is an array of values (cells). Any formatting information is ignored. Any individual sheet is organized into A header row Zero or more column configuration rows One or more element rows Header line The first row is a header row. Each column must be non-null and unique In future grouping columns may be possible There is always exactly one header row The header row must be first Each value must be unique The header row provides an index into subsequent rows Column Configurations Any subsequent rows where the first value start with a > character are column configurations A column configuration can be split over multiple lines Each line must be a valid yaml string (note that a single token is valid yaml for that token) The first config line must include a descriptor Subsequent lines are settings for that descriptor A descriptor can be one of: Any LinkML metamodel slot (e.g. description, comments, range, required, recommended, multivalued) The keyword cardinality . See Cardinality enum in datamodel An element metatype (schema, prefix, class, enum, slot, type, subset, permissible_value) Setting can be taken from configschema.yaml vmap provides a mapping used to translate column values. E.g. a custom \"yes\" or \"no\" to \"true\" or \"false\" various keys provide ways to auto-prefix or manipulate strings Element Rows Remaining rows are elements of your schema Each element gets its own row A row can represent a class (record, table), field (column), enumeration, or other element types If a metatype descriptor is used: the type of the row is indicated by the metatype value (one of: class, slot, enum, type, schema) a name field must be present, this indicates the name of the element If a metatype descriptor is note used: some combination of class, slot, enum, permissible value schema, type are used to determine the row type plus the name if both class and slot are populated the row is interpreted as slot_usage if only class is populated the row is a class element with name determined by the value of the class column if only slot is populated the row is a slot element with name determined by the value of the slot column if only type is populated the row is a type element with name determined by the value of the type column if only enum is populated the row is a enum element with name determined by the value of the enum column if both enum and permissible_value are populated the row is a permissible value element for that enum if permissible_value must not be populated without enum being populated if only schema is populated the row is a scheme element with name determined by the value of the schema column schema column may be populated in conjunction with any of the combination above to place the element in a schema all other combinations are forbidden All sheets/TSVs are combined together into a single LinkML schema as YAML This LinkML schema can be translated to other formats as per the LinkML generators Translating sheets to LinkML","title":"Specification (in progress)"},{"location":"specification/#specification-in-progress","text":"The following is an outline. Please refer to the above examples for elucidation.","title":"Specification (in progress)"},{"location":"specification/#sheet-structure","text":"A sheet is conceptualized as a collection of rows, which is an array of values (cells). Any formatting information is ignored. Any individual sheet is organized into A header row Zero or more column configuration rows One or more element rows","title":"Sheet Structure"},{"location":"specification/#header-line","text":"The first row is a header row. Each column must be non-null and unique In future grouping columns may be possible There is always exactly one header row The header row must be first Each value must be unique The header row provides an index into subsequent rows","title":"Header line"},{"location":"specification/#column-configurations","text":"Any subsequent rows where the first value start with a > character are column configurations A column configuration can be split over multiple lines Each line must be a valid yaml string (note that a single token is valid yaml for that token) The first config line must include a descriptor Subsequent lines are settings for that descriptor A descriptor can be one of: Any LinkML metamodel slot (e.g. description, comments, range, required, recommended, multivalued) The keyword cardinality . See Cardinality enum in datamodel An element metatype (schema, prefix, class, enum, slot, type, subset, permissible_value) Setting can be taken from configschema.yaml vmap provides a mapping used to translate column values. E.g. a custom \"yes\" or \"no\" to \"true\" or \"false\" various keys provide ways to auto-prefix or manipulate strings","title":"Column Configurations"},{"location":"specification/#element-rows","text":"Remaining rows are elements of your schema Each element gets its own row A row can represent a class (record, table), field (column), enumeration, or other element types If a metatype descriptor is used: the type of the row is indicated by the metatype value (one of: class, slot, enum, type, schema) a name field must be present, this indicates the name of the element If a metatype descriptor is note used: some combination of class, slot, enum, permissible value schema, type are used to determine the row type plus the name if both class and slot are populated the row is interpreted as slot_usage if only class is populated the row is a class element with name determined by the value of the class column if only slot is populated the row is a slot element with name determined by the value of the slot column if only type is populated the row is a type element with name determined by the value of the type column if only enum is populated the row is a enum element with name determined by the value of the enum column if both enum and permissible_value are populated the row is a permissible value element for that enum if permissible_value must not be populated without enum being populated if only schema is populated the row is a scheme element with name determined by the value of the schema column schema column may be populated in conjunction with any of the combination above to place the element in a schema all other combinations are forbidden All sheets/TSVs are combined together into a single LinkML schema as YAML This LinkML schema can be translated to other formats as per the LinkML generators","title":"Element Rows"},{"location":"specification/#translating-sheets-to-linkml","text":"","title":"Translating sheets to LinkML"},{"location":"datamodel/","text":"Schemasheets-Mappings schema This is the datamodel for Schemasheets Configurations. Note that for most purposes you will likely not need to consult this. The key class is ColumnSettings Two controlled vocabularies are specified here: Cardinality - terms and abbreviations that can be used for cardinality Shortcuts - species column configurations Classes ColumnSettings - configuration for an individual column in a schema sheet. ValueMap - A key-value dictionary Mixins Slots \u279eapplies_to_class - if a value C is specified, then this column in the relevant row is interpreted as \u279eapplies_to_slot \u279ecurie_prefix - CURIE prefix prepended to column value. This may be used for column that describe mapping or class/slot uri properties of the element. For example, with column settings exact_mapping: {curie_prefix: dcterms} , an element row with column value contributor , the value will be transformed to dcterms:contributor \u279eprefix - string to be prefixed onto the column value \u279esuffix - string to be suffixied onto the column value \u279etag \u279etemplate - jinja templated format string \u279evmap - Specifies a mapping for column values map_key - key in the dictionary map_value - key in the dictionary Enums Cardinality - vocabulary for describing cardinality and applicability of slots or fields. Shortcuts - A vocabulary of permissible values as column descriptors that do not have an exact equivalent in the LinkML datamodel, Subsets Types Built in Bool Decimal ElementIdentifier NCName NodeIdentifier URI URIorCURIE XSDDate XSDDateTime XSDTime float int str Defined ElementReference ( str ) - A pointer to an element in a datamodel Boolean ( Bool ) - A binary (true or false) value Date ( XSDDate ) - a date (year, month and day) in an idealized calendar Datetime ( XSDDateTime ) - The combination of a date and time Decimal ( Decimal ) - A real number with arbitrary precision that conforms to the xsd:decimal specification Double ( float ) - A real number that conforms to the xsd:double specification Float ( float ) - A real number that conforms to the xsd:float specification Integer ( int ) - An integer Ncname ( NCName ) - Prefix part of CURIE Nodeidentifier ( NodeIdentifier ) - A URI, CURIE or BNODE that represents a node in a model. Objectidentifier ( ElementIdentifier ) - A URI or CURIE that represents an object in the model. String ( str ) - A character string Time ( XSDTime ) - A time object represents a (local) time of day, independent of any particular day Uri ( URI ) - a complete URI Uriorcurie ( URIorCURIE ) - a URI or a CURIE","title":"Schemasheets-Mappings schema"},{"location":"datamodel/#schemasheets-mappings-schema","text":"This is the datamodel for Schemasheets Configurations. Note that for most purposes you will likely not need to consult this. The key class is ColumnSettings Two controlled vocabularies are specified here: Cardinality - terms and abbreviations that can be used for cardinality Shortcuts - species column configurations","title":"Schemasheets-Mappings schema"},{"location":"datamodel/#classes","text":"ColumnSettings - configuration for an individual column in a schema sheet. ValueMap - A key-value dictionary","title":"Classes"},{"location":"datamodel/#mixins","text":"","title":"Mixins"},{"location":"datamodel/#slots","text":"\u279eapplies_to_class - if a value C is specified, then this column in the relevant row is interpreted as \u279eapplies_to_slot \u279ecurie_prefix - CURIE prefix prepended to column value. This may be used for column that describe mapping or class/slot uri properties of the element. For example, with column settings exact_mapping: {curie_prefix: dcterms} , an element row with column value contributor , the value will be transformed to dcterms:contributor \u279eprefix - string to be prefixed onto the column value \u279esuffix - string to be suffixied onto the column value \u279etag \u279etemplate - jinja templated format string \u279evmap - Specifies a mapping for column values map_key - key in the dictionary map_value - key in the dictionary","title":"Slots"},{"location":"datamodel/#enums","text":"Cardinality - vocabulary for describing cardinality and applicability of slots or fields. Shortcuts - A vocabulary of permissible values as column descriptors that do not have an exact equivalent in the LinkML datamodel,","title":"Enums"},{"location":"datamodel/#subsets","text":"","title":"Subsets"},{"location":"datamodel/#types","text":"","title":"Types"},{"location":"datamodel/#built-in","text":"Bool Decimal ElementIdentifier NCName NodeIdentifier URI URIorCURIE XSDDate XSDDateTime XSDTime float int str","title":"Built in"},{"location":"datamodel/#defined","text":"ElementReference ( str ) - A pointer to an element in a datamodel Boolean ( Bool ) - A binary (true or false) value Date ( XSDDate ) - a date (year, month and day) in an idealized calendar Datetime ( XSDDateTime ) - The combination of a date and time Decimal ( Decimal ) - A real number with arbitrary precision that conforms to the xsd:decimal specification Double ( float ) - A real number that conforms to the xsd:double specification Float ( float ) - A real number that conforms to the xsd:float specification Integer ( int ) - An integer Ncname ( NCName ) - Prefix part of CURIE Nodeidentifier ( NodeIdentifier ) - A URI, CURIE or BNODE that represents a node in a model. Objectidentifier ( ElementIdentifier ) - A URI or CURIE that represents an object in the model. String ( str ) - A character string Time ( XSDTime ) - A time object represents a (local) time of day, independent of any particular day Uri ( URI ) - a complete URI Uriorcurie ( URIorCURIE ) - a URI or a CURIE","title":"Defined"},{"location":"datamodel/Cardinality/","text":"Enum: Cardinality vocabulary for describing cardinality and applicability of slots or fields. Most elements in the dictionary have been mapped to a vocabulary called \"carvoc\", this has yet to be released. URI: schemasheets:Cardinality Other properties Aliases: multiplicity applicability Permissible Values Text Description Meaning Other Information mandatory At least one value MUST be provided carvoc:Mandatory {'annotations': {'maps_to': Annotation(tag='maps_to', value='required: true', extensions={}, annotations={}), 'min': Annotation(tag='min', value='1', extensions={}, annotations={}), 'opposite': Annotation(tag='opposite', value='optional', extensions={}, annotations={}), 'interpretation': Annotation(tag='interpretation', value='MUST', extensions={}, annotations={}), 'aliases': Annotation(tag='aliases', value='required', extensions={}, annotations={}), 'mixs_notation': Annotation(tag='mixs_notation', value='M', extensions={}, annotations={}), 'code': Annotation(tag='code', value='M', extensions={}, annotations={})}} optional A value MAY be provided carvoc:Optional {'annotations': {'maps_to': Annotation(tag='maps_to', value='required: false', extensions={}, annotations={}), 'min': Annotation(tag='min', value='0', extensions={}, annotations={}), 'opposite': Annotation(tag='opposite', value='mandatory', extensions={}, annotations={}), 'interpretation': Annotation(tag='interpretation', value='MAY', extensions={}, annotations={}), 'aliases': Annotation(tag='aliases', value='permissible', extensions={}, annotations={}), 'mixs_notation': Annotation(tag='mixs_notation', value='X', extensions={}, annotations={}), 'code': Annotation(tag='code', value='O', extensions={}, annotations={})}} recommended A value SHOULD be provided carvoc:Recommended {'annotations': {'maps_to': Annotation(tag='maps_to', value='{required: false, recommended: true}', extensions={}, annotations={}), 'min': Annotation(tag='min', value='0', extensions={}, annotations={}), 'opposite': Annotation(tag='opposite', value='not_recommended', extensions={}, annotations={}), 'interpretation': Annotation(tag='interpretation', value='SHOULD', extensions={}, annotations={}), 'aliases': Annotation(tag='aliases', value='strongly suggested', extensions={}, annotations={}), 'code': Annotation(tag='code', value='R', extensions={}, annotations={})}} not_recommended Values are permitted, but SHOULD NOT be filled in carvoc:NotRecommended {'annotations': {'maps_to': Annotation(tag='maps_to', value='{required: false, recommended: false, recommended_against: true}', extensions={}, annotations={}), 'min': Annotation(tag='min', value='0', extensions={}, annotations={}), 'opposite': Annotation(tag='opposite', value='recommended', extensions={}, annotations={}), 'interpretation': Annotation(tag='interpretation', value='SHOULD NOT', extensions={}, annotations={}), 'aliases': Annotation(tag='aliases', value='recommended against', extensions={}, annotations={}), 'code': Annotation(tag='code', value='-R', extensions={}, annotations={})}} applicable union of optional and mandatory carvoc:Applicable {'annotations': {'min': Annotation(tag='min', value='0', extensions={}, annotations={}), 'opposite': Annotation(tag='opposite', value='not_applicable', extensions={}, annotations={}), 'interpretation': Annotation(tag='interpretation', value='MAY', extensions={}, annotations={}), 'code': Annotation(tag='code', value='O/M', extensions={}, annotations={})}, 'comments': ['use of this descriptor is generally not recommendes as it is usually possible to commit']} not_applicable A value MUST NOT be provided carvoc:NotApplicable {'annotations': {'max': Annotation(tag='max', value='0', extensions={}, annotations={}), 'min': Annotation(tag='min', value='0', extensions={}, annotations={}), 'opposite': Annotation(tag='opposite', value='applicable', extensions={}, annotations={}), 'interpretation': Annotation(tag='interpretation', value='MUST NOT', extensions={}, annotations={}), 'mixs_notation': Annotation(tag='mixs_notation', value='-', extensions={}, annotations={}), 'code': Annotation(tag='code', value='-', extensions={}, annotations={})}, 'comments': ['a use case for this is for a field that has been deprecated', 'a use case for this is for annotating a field that is not applicable in a particular context']} zero_or_one not required, single-valued carvoc:ZeroToOne {'mixins': ['optional', 'single-valued'], 'annotations': {'maps_to': Annotation(tag='maps_to', value='{required: false, multivalued: false}', extensions={}, annotations={}), 'min': Annotation(tag='min', value='0', extensions={}, annotations={}), 'max': Annotation(tag='max', value='1', extensions={}, annotations={}), 'interpretation': Annotation(tag='interpretation', value='MUST, MAY', extensions={}, annotations={}), 'uml': Annotation(tag='uml', value='0..1', extensions={}, annotations={}), 'code': Annotation(tag='code', value='0..1', extensions={}, annotations={})}} exactly_one required, single-valued carvoc:ExactlyOne {'mixins': ['mandatory', 'single-valued'], 'annotations': {'maps_to': Annotation(tag='maps_to', value='{required: true, multivalued: false}', extensions={}, annotations={}), 'min': Annotation(tag='min', value='1', extensions={}, annotations={}), 'max': Annotation(tag='max', value='1', extensions={}, annotations={}), 'interpretation': Annotation(tag='interpretation', value='MUST', extensions={}, annotations={}), 'uml': Annotation(tag='uml', value='1..1', extensions={}, annotations={}), 'code': Annotation(tag='code', value='1..1', extensions={}, annotations={})}} zero_to_many not required, multi-valued carvoc:ZeroToMany {'mixins': ['optional', 'multi-valued'], 'annotations': {'maps_to': Annotation(tag='maps_to', value='{required: false, multivalued: true}', extensions={}, annotations={}), 'min': Annotation(tag='min', value='0', extensions={}, annotations={}), 'max': Annotation(tag='max', value=' ', extensions={}, annotations={}), 'interpretation': Annotation(tag='interpretation', value='MAY', extensions={}, annotations={}), 'uml': Annotation(tag='uml', value='0.. ', extensions={}, annotations={}), 'code': Annotation(tag='code', value='0..*', extensions={}, annotations={})}} one_to_many required, multi-valued carvoc:OneToMany {'mixins': ['mandatory', 'multi-valued'], 'annotations': {'maps_to': Annotation(tag='maps_to', value='{required: true, multivalued: true}', extensions={}, annotations={}), 'min': Annotation(tag='min', value='1', extensions={}, annotations={}), 'max': Annotation(tag='max', value=' ', extensions={}, annotations={}), 'interpretation': Annotation(tag='interpretation', value='MUST, MAY', extensions={}, annotations={}), 'uml': Annotation(tag='uml', value='1.. ', extensions={}, annotations={}), 'code': Annotation(tag='code', value='1..*', extensions={}, annotations={})}} single_valued not multi-valued carvoc:SingleValued {'annotations': {'maps_to': Annotation(tag='maps_to', value='multivalued: false', extensions={}, annotations={}), 'max': Annotation(tag='max', value='1', extensions={}, annotations={}), 'opposite': Annotation(tag='opposite', value='multi-valued', extensions={}, annotations={}), 'interpretation': Annotation(tag='interpretation', value='MAY', extensions={}, annotations={}), 'mixs_notation': Annotation(tag='mixs_notation', value='1', extensions={}, annotations={}), 'code': Annotation(tag='code', value='SV', extensions={}, annotations={})}} multi_valued multi-valued carvoc:MultiValued {'annotations': {'maps_to': Annotation(tag='maps_to', value='multivalued: true', extensions={}, annotations={}), 'max': Annotation(tag='max', value='*', extensions={}, annotations={}), 'opposite': Annotation(tag='opposite', value='single-valued', extensions={}, annotations={}), 'interpretation': Annotation(tag='interpretation', value='MAY', extensions={}, annotations={}), 'mixs_notation': Annotation(tag='mixs_notation', value='m', extensions={}, annotations={}), 'code': Annotation(tag='code', value='MV', extensions={}, annotations={})}} conditional A qualifier on cardinalities that indicates the interpretation is context-dependent carvoc:Conditional {'annotations': {'maps_to': Annotation(tag='maps_to', value='conditional: true', extensions={}, annotations={}), 'mixs_notation': Annotation(tag='mixs_notation', value='E', extensions={}, annotations={}), 'code': Annotation(tag='code', value='E+', extensions={}, annotations={})}} unconditional A qualifier on cardinalities that indicates the interpretation is context-independent carvoc:Unconditional {'annotations': {'maps_to': Annotation(tag='maps_to', value='conditional: false', extensions={}, annotations={}), 'code': Annotation(tag='code', value='E-', extensions={}, annotations={})}} conditional_mandatory carvoc:ConditionalMandatory {'mixins': ['mandatory', 'conditional'], 'annotations': {'maps_to': Annotation(tag='maps_to', value='{required: true, conditional: true}', extensions={}, annotations={}), 'mixs_notation': Annotation(tag='mixs_notation', value='C', extensions={}, annotations={}), 'code': Annotation(tag='code', value='EM', extensions={}, annotations={})}}","title":"Enum: Cardinality"},{"location":"datamodel/Cardinality/#enum-cardinality","text":"vocabulary for describing cardinality and applicability of slots or fields. Most elements in the dictionary have been mapped to a vocabulary called \"carvoc\", this has yet to be released. URI: schemasheets:Cardinality","title":"Enum: Cardinality"},{"location":"datamodel/Cardinality/#other-properties","text":"Aliases: multiplicity applicability","title":"Other properties"},{"location":"datamodel/Cardinality/#permissible-values","text":"Text Description Meaning Other Information mandatory At least one value MUST be provided carvoc:Mandatory {'annotations': {'maps_to': Annotation(tag='maps_to', value='required: true', extensions={}, annotations={}), 'min': Annotation(tag='min', value='1', extensions={}, annotations={}), 'opposite': Annotation(tag='opposite', value='optional', extensions={}, annotations={}), 'interpretation': Annotation(tag='interpretation', value='MUST', extensions={}, annotations={}), 'aliases': Annotation(tag='aliases', value='required', extensions={}, annotations={}), 'mixs_notation': Annotation(tag='mixs_notation', value='M', extensions={}, annotations={}), 'code': Annotation(tag='code', value='M', extensions={}, annotations={})}} optional A value MAY be provided carvoc:Optional {'annotations': {'maps_to': Annotation(tag='maps_to', value='required: false', extensions={}, annotations={}), 'min': Annotation(tag='min', value='0', extensions={}, annotations={}), 'opposite': Annotation(tag='opposite', value='mandatory', extensions={}, annotations={}), 'interpretation': Annotation(tag='interpretation', value='MAY', extensions={}, annotations={}), 'aliases': Annotation(tag='aliases', value='permissible', extensions={}, annotations={}), 'mixs_notation': Annotation(tag='mixs_notation', value='X', extensions={}, annotations={}), 'code': Annotation(tag='code', value='O', extensions={}, annotations={})}} recommended A value SHOULD be provided carvoc:Recommended {'annotations': {'maps_to': Annotation(tag='maps_to', value='{required: false, recommended: true}', extensions={}, annotations={}), 'min': Annotation(tag='min', value='0', extensions={}, annotations={}), 'opposite': Annotation(tag='opposite', value='not_recommended', extensions={}, annotations={}), 'interpretation': Annotation(tag='interpretation', value='SHOULD', extensions={}, annotations={}), 'aliases': Annotation(tag='aliases', value='strongly suggested', extensions={}, annotations={}), 'code': Annotation(tag='code', value='R', extensions={}, annotations={})}} not_recommended Values are permitted, but SHOULD NOT be filled in carvoc:NotRecommended {'annotations': {'maps_to': Annotation(tag='maps_to', value='{required: false, recommended: false, recommended_against: true}', extensions={}, annotations={}), 'min': Annotation(tag='min', value='0', extensions={}, annotations={}), 'opposite': Annotation(tag='opposite', value='recommended', extensions={}, annotations={}), 'interpretation': Annotation(tag='interpretation', value='SHOULD NOT', extensions={}, annotations={}), 'aliases': Annotation(tag='aliases', value='recommended against', extensions={}, annotations={}), 'code': Annotation(tag='code', value='-R', extensions={}, annotations={})}} applicable union of optional and mandatory carvoc:Applicable {'annotations': {'min': Annotation(tag='min', value='0', extensions={}, annotations={}), 'opposite': Annotation(tag='opposite', value='not_applicable', extensions={}, annotations={}), 'interpretation': Annotation(tag='interpretation', value='MAY', extensions={}, annotations={}), 'code': Annotation(tag='code', value='O/M', extensions={}, annotations={})}, 'comments': ['use of this descriptor is generally not recommendes as it is usually possible to commit']} not_applicable A value MUST NOT be provided carvoc:NotApplicable {'annotations': {'max': Annotation(tag='max', value='0', extensions={}, annotations={}), 'min': Annotation(tag='min', value='0', extensions={}, annotations={}), 'opposite': Annotation(tag='opposite', value='applicable', extensions={}, annotations={}), 'interpretation': Annotation(tag='interpretation', value='MUST NOT', extensions={}, annotations={}), 'mixs_notation': Annotation(tag='mixs_notation', value='-', extensions={}, annotations={}), 'code': Annotation(tag='code', value='-', extensions={}, annotations={})}, 'comments': ['a use case for this is for a field that has been deprecated', 'a use case for this is for annotating a field that is not applicable in a particular context']} zero_or_one not required, single-valued carvoc:ZeroToOne {'mixins': ['optional', 'single-valued'], 'annotations': {'maps_to': Annotation(tag='maps_to', value='{required: false, multivalued: false}', extensions={}, annotations={}), 'min': Annotation(tag='min', value='0', extensions={}, annotations={}), 'max': Annotation(tag='max', value='1', extensions={}, annotations={}), 'interpretation': Annotation(tag='interpretation', value='MUST, MAY', extensions={}, annotations={}), 'uml': Annotation(tag='uml', value='0..1', extensions={}, annotations={}), 'code': Annotation(tag='code', value='0..1', extensions={}, annotations={})}} exactly_one required, single-valued carvoc:ExactlyOne {'mixins': ['mandatory', 'single-valued'], 'annotations': {'maps_to': Annotation(tag='maps_to', value='{required: true, multivalued: false}', extensions={}, annotations={}), 'min': Annotation(tag='min', value='1', extensions={}, annotations={}), 'max': Annotation(tag='max', value='1', extensions={}, annotations={}), 'interpretation': Annotation(tag='interpretation', value='MUST', extensions={}, annotations={}), 'uml': Annotation(tag='uml', value='1..1', extensions={}, annotations={}), 'code': Annotation(tag='code', value='1..1', extensions={}, annotations={})}} zero_to_many not required, multi-valued carvoc:ZeroToMany {'mixins': ['optional', 'multi-valued'], 'annotations': {'maps_to': Annotation(tag='maps_to', value='{required: false, multivalued: true}', extensions={}, annotations={}), 'min': Annotation(tag='min', value='0', extensions={}, annotations={}), 'max': Annotation(tag='max', value=' ', extensions={}, annotations={}), 'interpretation': Annotation(tag='interpretation', value='MAY', extensions={}, annotations={}), 'uml': Annotation(tag='uml', value='0.. ', extensions={}, annotations={}), 'code': Annotation(tag='code', value='0..*', extensions={}, annotations={})}} one_to_many required, multi-valued carvoc:OneToMany {'mixins': ['mandatory', 'multi-valued'], 'annotations': {'maps_to': Annotation(tag='maps_to', value='{required: true, multivalued: true}', extensions={}, annotations={}), 'min': Annotation(tag='min', value='1', extensions={}, annotations={}), 'max': Annotation(tag='max', value=' ', extensions={}, annotations={}), 'interpretation': Annotation(tag='interpretation', value='MUST, MAY', extensions={}, annotations={}), 'uml': Annotation(tag='uml', value='1.. ', extensions={}, annotations={}), 'code': Annotation(tag='code', value='1..*', extensions={}, annotations={})}} single_valued not multi-valued carvoc:SingleValued {'annotations': {'maps_to': Annotation(tag='maps_to', value='multivalued: false', extensions={}, annotations={}), 'max': Annotation(tag='max', value='1', extensions={}, annotations={}), 'opposite': Annotation(tag='opposite', value='multi-valued', extensions={}, annotations={}), 'interpretation': Annotation(tag='interpretation', value='MAY', extensions={}, annotations={}), 'mixs_notation': Annotation(tag='mixs_notation', value='1', extensions={}, annotations={}), 'code': Annotation(tag='code', value='SV', extensions={}, annotations={})}} multi_valued multi-valued carvoc:MultiValued {'annotations': {'maps_to': Annotation(tag='maps_to', value='multivalued: true', extensions={}, annotations={}), 'max': Annotation(tag='max', value='*', extensions={}, annotations={}), 'opposite': Annotation(tag='opposite', value='single-valued', extensions={}, annotations={}), 'interpretation': Annotation(tag='interpretation', value='MAY', extensions={}, annotations={}), 'mixs_notation': Annotation(tag='mixs_notation', value='m', extensions={}, annotations={}), 'code': Annotation(tag='code', value='MV', extensions={}, annotations={})}} conditional A qualifier on cardinalities that indicates the interpretation is context-dependent carvoc:Conditional {'annotations': {'maps_to': Annotation(tag='maps_to', value='conditional: true', extensions={}, annotations={}), 'mixs_notation': Annotation(tag='mixs_notation', value='E', extensions={}, annotations={}), 'code': Annotation(tag='code', value='E+', extensions={}, annotations={})}} unconditional A qualifier on cardinalities that indicates the interpretation is context-independent carvoc:Unconditional {'annotations': {'maps_to': Annotation(tag='maps_to', value='conditional: false', extensions={}, annotations={}), 'code': Annotation(tag='code', value='E-', extensions={}, annotations={})}} conditional_mandatory carvoc:ConditionalMandatory {'mixins': ['mandatory', 'conditional'], 'annotations': {'maps_to': Annotation(tag='maps_to', value='{required: true, conditional: true}', extensions={}, annotations={}), 'mixs_notation': Annotation(tag='mixs_notation', value='C', extensions={}, annotations={}), 'code': Annotation(tag='code', value='EM', extensions={}, annotations={})}}","title":"Permissible Values"},{"location":"datamodel/ColumnSettings/","text":"Class: ColumnSettings configuration for an individual column in a schema sheet. These settings are typically specified as YAML blocks beneath the relevant column header, for example: > class URI: schemasheets:ColumnSettings Attributes Own \u279ecurie_prefix 0..1 Description: CURIE prefix prepended to column value. This may be used for column that describe mapping or class/slot uri properties of the element. For example, with column settings exact_mapping: {curie_prefix: dcterms} , an element row with column value contributor , the value will be transformed to dcterms:contributor Range: String \u279eprefix 0..1 Description: string to be prefixed onto the column value Range: String \u279esuffix 0..1 Description: string to be suffixied onto the column value Range: String \u279etemplate 0..1 Description: jinja templated format string Range: String \u279evmap 0..* Description: Specifies a mapping for column values Range: ValueMap \u279eapplies_to_class 0..1 Description: if a value C is specified, then this column in the relevant row is interpreted as pertaining to C Range: ElementReference \u279eapplies_to_slot 0..1 Range: ElementReference \u279etag 0..1 Range: String","title":"Class: ColumnSettings"},{"location":"datamodel/ColumnSettings/#class-columnsettings","text":"configuration for an individual column in a schema sheet. These settings are typically specified as YAML blocks beneath the relevant column header, for example: > class URI: schemasheets:ColumnSettings","title":"Class: ColumnSettings"},{"location":"datamodel/ColumnSettings/#attributes","text":"","title":"Attributes"},{"location":"datamodel/ColumnSettings/#own","text":"\u279ecurie_prefix 0..1 Description: CURIE prefix prepended to column value. This may be used for column that describe mapping or class/slot uri properties of the element. For example, with column settings exact_mapping: {curie_prefix: dcterms} , an element row with column value contributor , the value will be transformed to dcterms:contributor Range: String \u279eprefix 0..1 Description: string to be prefixed onto the column value Range: String \u279esuffix 0..1 Description: string to be suffixied onto the column value Range: String \u279etemplate 0..1 Description: jinja templated format string Range: String \u279evmap 0..* Description: Specifies a mapping for column values Range: ValueMap \u279eapplies_to_class 0..1 Description: if a value C is specified, then this column in the relevant row is interpreted as pertaining to C Range: ElementReference \u279eapplies_to_slot 0..1 Range: ElementReference \u279etag 0..1 Range: String","title":"Own"},{"location":"datamodel/Shortcuts/","text":"Enum: Shortcuts A vocabulary of permissible values as column descriptors that do not have an exact equivalent in the LinkML datamodel, and instead act as shortcuts to either a collection of elements or a type of mapping behavior URI: schemasheets:Shortcuts Other properties Permissible Values Text Description Meaning Other Information cardinality The column is used to describe the cardinality of a slot, with values from the Cardinality enum ignore The column is ignored metatype The column describes what kind of element is specified in the row class The column is populated with class names linkml:ClassDefinition slot The column is populated with slot names linkml:SlotDefinition enum The column is populated with enum names linkml:EnumDefinition schema The column is populated with schema names linkml:EnumDefinition subset The column is populated with subset names linkml:EnumDefinition","title":"Enum: Shortcuts"},{"location":"datamodel/Shortcuts/#enum-shortcuts","text":"A vocabulary of permissible values as column descriptors that do not have an exact equivalent in the LinkML datamodel, and instead act as shortcuts to either a collection of elements or a type of mapping behavior URI: schemasheets:Shortcuts","title":"Enum: Shortcuts"},{"location":"datamodel/Shortcuts/#other-properties","text":"","title":"Other properties"},{"location":"datamodel/Shortcuts/#permissible-values","text":"Text Description Meaning Other Information cardinality The column is used to describe the cardinality of a slot, with values from the Cardinality enum ignore The column is ignored metatype The column describes what kind of element is specified in the row class The column is populated with class names linkml:ClassDefinition slot The column is populated with slot names linkml:SlotDefinition enum The column is populated with enum names linkml:EnumDefinition schema The column is populated with schema names linkml:EnumDefinition subset The column is populated with subset names linkml:EnumDefinition","title":"Permissible Values"},{"location":"datamodel/ValueMap/","text":"Class: ValueMap A key-value dictionary URI: schemasheets:ValueMap Referenced by Class None \u279evmap 0..* ValueMap Attributes Own map_key 1..1 Description: key in the dictionary Range: String map_value 0..1 Description: key in the dictionary Range: String","title":"Class: ValueMap"},{"location":"datamodel/ValueMap/#class-valuemap","text":"A key-value dictionary URI: schemasheets:ValueMap","title":"Class: ValueMap"},{"location":"datamodel/ValueMap/#referenced-by-class","text":"None \u279evmap 0..* ValueMap","title":"Referenced by Class"},{"location":"datamodel/ValueMap/#attributes","text":"","title":"Attributes"},{"location":"datamodel/ValueMap/#own","text":"map_key 1..1 Description: key in the dictionary Range: String map_value 0..1 Description: key in the dictionary Range: String","title":"Own"},{"location":"datamodel/columnSettings__applies_to_class/","text":"Slot: applies_to_class if a value C is specified, then this column in the relevant row is interpreted as pertaining to C URI: schemasheets:columnSettings__applies_to_class Domain and Range None \u2192 0..1 ElementReference Parents Children Used by ColumnSettings","title":"Slot: applies_to_class"},{"location":"datamodel/columnSettings__applies_to_class/#slot-applies_to_class","text":"if a value C is specified, then this column in the relevant row is interpreted as pertaining to C URI: schemasheets:columnSettings__applies_to_class","title":"Slot: applies_to_class"},{"location":"datamodel/columnSettings__applies_to_class/#domain-and-range","text":"None \u2192 0..1 ElementReference","title":"Domain and Range"},{"location":"datamodel/columnSettings__applies_to_class/#parents","text":"","title":"Parents"},{"location":"datamodel/columnSettings__applies_to_class/#children","text":"","title":"Children"},{"location":"datamodel/columnSettings__applies_to_class/#used-by","text":"ColumnSettings","title":"Used by"},{"location":"datamodel/columnSettings__applies_to_slot/","text":"Slot: applies_to_slot URI: schemasheets:columnSettings__applies_to_slot Domain and Range None \u2192 0..1 ElementReference Parents Children Used by ColumnSettings","title":"Slot: applies_to_slot"},{"location":"datamodel/columnSettings__applies_to_slot/#slot-applies_to_slot","text":"URI: schemasheets:columnSettings__applies_to_slot","title":"Slot: applies_to_slot"},{"location":"datamodel/columnSettings__applies_to_slot/#domain-and-range","text":"None \u2192 0..1 ElementReference","title":"Domain and Range"},{"location":"datamodel/columnSettings__applies_to_slot/#parents","text":"","title":"Parents"},{"location":"datamodel/columnSettings__applies_to_slot/#children","text":"","title":"Children"},{"location":"datamodel/columnSettings__applies_to_slot/#used-by","text":"ColumnSettings","title":"Used by"},{"location":"datamodel/columnSettings__curie_prefix/","text":"Slot: curie_prefix CURIE prefix prepended to column value. This may be used for column that describe mapping or class/slot uri properties of the element. For example, with column settings exact_mapping: {curie_prefix: dcterms} , an element row with column value contributor , the value will be transformed to dcterms:contributor URI: schemasheets:columnSettings__curie_prefix Domain and Range None \u2192 0..1 String Parents Children Used by ColumnSettings","title":"Slot: curie_prefix"},{"location":"datamodel/columnSettings__curie_prefix/#slot-curie_prefix","text":"CURIE prefix prepended to column value. This may be used for column that describe mapping or class/slot uri properties of the element. For example, with column settings exact_mapping: {curie_prefix: dcterms} , an element row with column value contributor , the value will be transformed to dcterms:contributor URI: schemasheets:columnSettings__curie_prefix","title":"Slot: curie_prefix"},{"location":"datamodel/columnSettings__curie_prefix/#domain-and-range","text":"None \u2192 0..1 String","title":"Domain and Range"},{"location":"datamodel/columnSettings__curie_prefix/#parents","text":"","title":"Parents"},{"location":"datamodel/columnSettings__curie_prefix/#children","text":"","title":"Children"},{"location":"datamodel/columnSettings__curie_prefix/#used-by","text":"ColumnSettings","title":"Used by"},{"location":"datamodel/columnSettings__prefix/","text":"Slot: prefix string to be prefixed onto the column value URI: schemasheets:columnSettings__prefix Domain and Range None \u2192 0..1 String Parents Children Used by ColumnSettings","title":"Slot: prefix"},{"location":"datamodel/columnSettings__prefix/#slot-prefix","text":"string to be prefixed onto the column value URI: schemasheets:columnSettings__prefix","title":"Slot: prefix"},{"location":"datamodel/columnSettings__prefix/#domain-and-range","text":"None \u2192 0..1 String","title":"Domain and Range"},{"location":"datamodel/columnSettings__prefix/#parents","text":"","title":"Parents"},{"location":"datamodel/columnSettings__prefix/#children","text":"","title":"Children"},{"location":"datamodel/columnSettings__prefix/#used-by","text":"ColumnSettings","title":"Used by"},{"location":"datamodel/columnSettings__suffix/","text":"Slot: suffix string to be suffixied onto the column value URI: schemasheets:columnSettings__suffix Domain and Range None \u2192 0..1 String Parents Children Used by ColumnSettings","title":"Slot: suffix"},{"location":"datamodel/columnSettings__suffix/#slot-suffix","text":"string to be suffixied onto the column value URI: schemasheets:columnSettings__suffix","title":"Slot: suffix"},{"location":"datamodel/columnSettings__suffix/#domain-and-range","text":"None \u2192 0..1 String","title":"Domain and Range"},{"location":"datamodel/columnSettings__suffix/#parents","text":"","title":"Parents"},{"location":"datamodel/columnSettings__suffix/#children","text":"","title":"Children"},{"location":"datamodel/columnSettings__suffix/#used-by","text":"ColumnSettings","title":"Used by"},{"location":"datamodel/columnSettings__tag/","text":"Slot: tag URI: schemasheets:columnSettings__tag Domain and Range None \u2192 0..1 String Parents Children Used by ColumnSettings","title":"Slot: tag"},{"location":"datamodel/columnSettings__tag/#slot-tag","text":"URI: schemasheets:columnSettings__tag","title":"Slot: tag"},{"location":"datamodel/columnSettings__tag/#domain-and-range","text":"None \u2192 0..1 String","title":"Domain and Range"},{"location":"datamodel/columnSettings__tag/#parents","text":"","title":"Parents"},{"location":"datamodel/columnSettings__tag/#children","text":"","title":"Children"},{"location":"datamodel/columnSettings__tag/#used-by","text":"ColumnSettings","title":"Used by"},{"location":"datamodel/columnSettings__template/","text":"Slot: template jinja templated format string URI: schemasheets:columnSettings__template Domain and Range None \u2192 0..1 String Parents Children Used by ColumnSettings","title":"Slot: template"},{"location":"datamodel/columnSettings__template/#slot-template","text":"jinja templated format string URI: schemasheets:columnSettings__template","title":"Slot: template"},{"location":"datamodel/columnSettings__template/#domain-and-range","text":"None \u2192 0..1 String","title":"Domain and Range"},{"location":"datamodel/columnSettings__template/#parents","text":"","title":"Parents"},{"location":"datamodel/columnSettings__template/#children","text":"","title":"Children"},{"location":"datamodel/columnSettings__template/#used-by","text":"ColumnSettings","title":"Used by"},{"location":"datamodel/columnSettings__vmap/","text":"Slot: vmap Specifies a mapping for column values URI: schemasheets:columnSettings__vmap Domain and Range None \u2192 0..* ValueMap Parents Children Used by ColumnSettings","title":"Slot: vmap"},{"location":"datamodel/columnSettings__vmap/#slot-vmap","text":"Specifies a mapping for column values URI: schemasheets:columnSettings__vmap","title":"Slot: vmap"},{"location":"datamodel/columnSettings__vmap/#domain-and-range","text":"None \u2192 0..* ValueMap","title":"Domain and Range"},{"location":"datamodel/columnSettings__vmap/#parents","text":"","title":"Parents"},{"location":"datamodel/columnSettings__vmap/#children","text":"","title":"Children"},{"location":"datamodel/columnSettings__vmap/#used-by","text":"ColumnSettings","title":"Used by"},{"location":"datamodel/map_key/","text":"Slot: map_key key in the dictionary URI: schemasheets:map_key Domain and Range None \u2192 1..1 String Parents Children Used by ValueMap","title":"Slot: map_key"},{"location":"datamodel/map_key/#slot-map_key","text":"key in the dictionary URI: schemasheets:map_key","title":"Slot: map_key"},{"location":"datamodel/map_key/#domain-and-range","text":"None \u2192 1..1 String","title":"Domain and Range"},{"location":"datamodel/map_key/#parents","text":"","title":"Parents"},{"location":"datamodel/map_key/#children","text":"","title":"Children"},{"location":"datamodel/map_key/#used-by","text":"ValueMap","title":"Used by"},{"location":"datamodel/map_value/","text":"Slot: map_value key in the dictionary URI: schemasheets:map_value Domain and Range None \u2192 0..1 String Parents Children Used by ValueMap","title":"Slot: map_value"},{"location":"datamodel/map_value/#slot-map_value","text":"key in the dictionary URI: schemasheets:map_value","title":"Slot: map_value"},{"location":"datamodel/map_value/#domain-and-range","text":"None \u2192 0..1 String","title":"Domain and Range"},{"location":"datamodel/map_value/#parents","text":"","title":"Parents"},{"location":"datamodel/map_value/#children","text":"","title":"Children"},{"location":"datamodel/map_value/#used-by","text":"ValueMap","title":"Used by"},{"location":"datamodel/docs/A/","text":"Subset: a URI: TEMP:a Classes Event - grouping class for events Mixins Slots Types Enums","title":"Subset: a"},{"location":"datamodel/docs/A/#subset-a","text":"URI: TEMP:a","title":"Subset: a"},{"location":"datamodel/docs/A/#classes","text":"Event - grouping class for events","title":"Classes"},{"location":"datamodel/docs/A/#mixins","text":"","title":"Mixins"},{"location":"datamodel/docs/A/#slots","text":"","title":"Slots"},{"location":"datamodel/docs/A/#types","text":"","title":"Types"},{"location":"datamodel/docs/A/#enums","text":"","title":"Enums"},{"location":"datamodel/docs/B/","text":"Subset: b URI: TEMP:b Classes MedicalEvent - a medical encounter Mixins Slots Types Enums","title":"Subset: b"},{"location":"datamodel/docs/B/#subset-b","text":"URI: TEMP:b","title":"Subset: b"},{"location":"datamodel/docs/B/#classes","text":"MedicalEvent - a medical encounter","title":"Classes"},{"location":"datamodel/docs/B/#mixins","text":"","title":"Mixins"},{"location":"datamodel/docs/B/#slots","text":"","title":"Slots"},{"location":"datamodel/docs/B/#types","text":"","title":"Types"},{"location":"datamodel/docs/B/#enums","text":"","title":"Enums"},{"location":"datamodel/docs/Event/","text":"Class: Event grouping class for events URI: TEMP:Event Children MedicalEvent - a medical encounter Referenced by Class Attributes Other properties In Subsets: a Exact Mappings: wikidata:Q1656682","title":"Class: Event"},{"location":"datamodel/docs/Event/#class-event","text":"grouping class for events URI: TEMP:Event","title":"Class: Event"},{"location":"datamodel/docs/Event/#children","text":"MedicalEvent - a medical encounter","title":"Children"},{"location":"datamodel/docs/Event/#referenced-by-class","text":"","title":"Referenced by Class"},{"location":"datamodel/docs/Event/#attributes","text":"","title":"Attributes"},{"location":"datamodel/docs/Event/#other-properties","text":"In Subsets: a Exact Mappings: wikidata:Q1656682","title":"Other properties"},{"location":"datamodel/docs/ForProfit/","text":"Class: ForProfit URI: TEMP:ForProfit Parents is_a: Organization Attributes Inherited from Organization: Organization\u279ename 1..1 Description: full name Range: String","title":"Class: ForProfit"},{"location":"datamodel/docs/ForProfit/#class-forprofit","text":"URI: TEMP:ForProfit","title":"Class: ForProfit"},{"location":"datamodel/docs/ForProfit/#parents","text":"is_a: Organization","title":"Parents"},{"location":"datamodel/docs/ForProfit/#attributes","text":"","title":"Attributes"},{"location":"datamodel/docs/ForProfit/#inherited-from-organization","text":"Organization\u279ename 1..1 Description: full name Range: String","title":"Inherited from Organization:"},{"location":"datamodel/docs/MedicalEvent/","text":"Class: MedicalEvent a medical encounter URI: TEMP:MedicalEvent Parents is_a: Event - grouping class for events Referenced by Class Person Person\u279ehas medical history 0..* MedicalEvent Attributes Other properties In Subsets: b","title":"Class: MedicalEvent"},{"location":"datamodel/docs/MedicalEvent/#class-medicalevent","text":"a medical encounter URI: TEMP:MedicalEvent","title":"Class: MedicalEvent"},{"location":"datamodel/docs/MedicalEvent/#parents","text":"is_a: Event - grouping class for events","title":"Parents"},{"location":"datamodel/docs/MedicalEvent/#referenced-by-class","text":"Person Person\u279ehas medical history 0..* MedicalEvent","title":"Referenced by Class"},{"location":"datamodel/docs/MedicalEvent/#attributes","text":"","title":"Attributes"},{"location":"datamodel/docs/MedicalEvent/#other-properties","text":"In Subsets: b","title":"Other properties"},{"location":"datamodel/docs/NonProfit/","text":"Class: NonProfit URI: TEMP:NonProfit Parents is_a: Organization Attributes Inherited from Organization: Organization\u279ename 1..1 Description: full name Range: String Other properties Exact Mappings: wikidata:Q163740","title":"Class: NonProfit"},{"location":"datamodel/docs/NonProfit/#class-nonprofit","text":"URI: TEMP:NonProfit","title":"Class: NonProfit"},{"location":"datamodel/docs/NonProfit/#parents","text":"is_a: Organization","title":"Parents"},{"location":"datamodel/docs/NonProfit/#attributes","text":"","title":"Attributes"},{"location":"datamodel/docs/NonProfit/#inherited-from-organization","text":"Organization\u279ename 1..1 Description: full name Range: String","title":"Inherited from Organization:"},{"location":"datamodel/docs/NonProfit/#other-properties","text":"Exact Mappings: wikidata:Q163740","title":"Other properties"},{"location":"datamodel/docs/Organization/","text":"Class: Organization URI: TEMP:Organization Children ForProfit NonProfit Referenced by Class Attributes Own Organization\u279ename 1..1 Description: full name Range: String","title":"Class: Organization"},{"location":"datamodel/docs/Organization/#class-organization","text":"URI: TEMP:Organization","title":"Class: Organization"},{"location":"datamodel/docs/Organization/#children","text":"ForProfit NonProfit","title":"Children"},{"location":"datamodel/docs/Organization/#referenced-by-class","text":"","title":"Referenced by Class"},{"location":"datamodel/docs/Organization/#attributes","text":"","title":"Attributes"},{"location":"datamodel/docs/Organization/#own","text":"Organization\u279ename 1..1 Description: full name Range: String","title":"Own"},{"location":"datamodel/docs/Organization_name/","text":"Slot: name full name URI: TEMP:Organization_name Domain and Range Organization \u2192 1..1 String Parents is_a: name Children Used by ForProfit NonProfit Organization Other properties Exact Mappings: sdo:name","title":"Slot: name"},{"location":"datamodel/docs/Organization_name/#slot-name","text":"full name URI: TEMP:Organization_name","title":"Slot: name"},{"location":"datamodel/docs/Organization_name/#domain-and-range","text":"Organization \u2192 1..1 String","title":"Domain and Range"},{"location":"datamodel/docs/Organization_name/#parents","text":"is_a: name","title":"Parents"},{"location":"datamodel/docs/Organization_name/#children","text":"","title":"Children"},{"location":"datamodel/docs/Organization_name/#used-by","text":"ForProfit NonProfit Organization","title":"Used by"},{"location":"datamodel/docs/Organization_name/#other-properties","text":"Exact Mappings: sdo:name","title":"Other properties"},{"location":"datamodel/docs/Person/","text":"Class: Person a person,living or dead URI: TEMP:Person Referenced by Class Attributes Own Person\u279eid 1..1 Description: identifier for a person Range: String Person\u279ename 1..1 Description: full name Range: String Person\u279eage 0..1 Description: age in years Range: Decimal Person\u279egender 0..1 Description: age in years Range: Decimal Person\u279ehas medical history 0..* Description: medical history Range: MedicalEvent Other properties Exact Mappings: sdo:Person wikidata:Q215627","title":"Class: Person"},{"location":"datamodel/docs/Person/#class-person","text":"a person,living or dead URI: TEMP:Person","title":"Class: Person"},{"location":"datamodel/docs/Person/#referenced-by-class","text":"","title":"Referenced by Class"},{"location":"datamodel/docs/Person/#attributes","text":"","title":"Attributes"},{"location":"datamodel/docs/Person/#own","text":"Person\u279eid 1..1 Description: identifier for a person Range: String Person\u279ename 1..1 Description: full name Range: String Person\u279eage 0..1 Description: age in years Range: Decimal Person\u279egender 0..1 Description: age in years Range: Decimal Person\u279ehas medical history 0..* Description: medical history Range: MedicalEvent","title":"Own"},{"location":"datamodel/docs/Person/#other-properties","text":"Exact Mappings: sdo:Person wikidata:Q215627","title":"Other properties"},{"location":"datamodel/docs/Person_age/","text":"Slot: age age in years URI: TEMP:Person_age Domain and Range Person \u2192 0..1 Decimal Parents is_a: age Children Used by Person","title":"Slot: age"},{"location":"datamodel/docs/Person_age/#slot-age","text":"age in years URI: TEMP:Person_age","title":"Slot: age"},{"location":"datamodel/docs/Person_age/#domain-and-range","text":"Person \u2192 0..1 Decimal","title":"Domain and Range"},{"location":"datamodel/docs/Person_age/#parents","text":"is_a: age","title":"Parents"},{"location":"datamodel/docs/Person_age/#children","text":"","title":"Children"},{"location":"datamodel/docs/Person_age/#used-by","text":"Person","title":"Used by"},{"location":"datamodel/docs/Person_gender/","text":"Slot: gender age in years URI: TEMP:Person_gender Domain and Range Person \u2192 0..1 Decimal Parents is_a: gender Children Used by Person","title":"Slot: gender"},{"location":"datamodel/docs/Person_gender/#slot-gender","text":"age in years URI: TEMP:Person_gender","title":"Slot: gender"},{"location":"datamodel/docs/Person_gender/#domain-and-range","text":"Person \u2192 0..1 Decimal","title":"Domain and Range"},{"location":"datamodel/docs/Person_gender/#parents","text":"is_a: gender","title":"Parents"},{"location":"datamodel/docs/Person_gender/#children","text":"","title":"Children"},{"location":"datamodel/docs/Person_gender/#used-by","text":"Person","title":"Used by"},{"location":"datamodel/docs/Person_has_medical_history/","text":"Slot: has medical history medical history URI: TEMP:Person_has_medical_history Domain and Range Person \u2192 0..* MedicalEvent Parents is_a: has medical history Children Used by Person","title":"Slot: has medical history"},{"location":"datamodel/docs/Person_has_medical_history/#slot-has-medical-history","text":"medical history URI: TEMP:Person_has_medical_history","title":"Slot: has medical history"},{"location":"datamodel/docs/Person_has_medical_history/#domain-and-range","text":"Person \u2192 0..* MedicalEvent","title":"Domain and Range"},{"location":"datamodel/docs/Person_has_medical_history/#parents","text":"is_a: has medical history","title":"Parents"},{"location":"datamodel/docs/Person_has_medical_history/#children","text":"","title":"Children"},{"location":"datamodel/docs/Person_has_medical_history/#used-by","text":"Person","title":"Used by"},{"location":"datamodel/docs/Person_id/","text":"Slot: id identifier for a person URI: TEMP:Person_id Domain and Range Person \u2192 1..1 String Parents is_a: id Children Used by Person Other properties Exact Mappings: sdo:identifier","title":"Slot: id"},{"location":"datamodel/docs/Person_id/#slot-id","text":"identifier for a person URI: TEMP:Person_id","title":"Slot: id"},{"location":"datamodel/docs/Person_id/#domain-and-range","text":"Person \u2192 1..1 String","title":"Domain and Range"},{"location":"datamodel/docs/Person_id/#parents","text":"is_a: id","title":"Parents"},{"location":"datamodel/docs/Person_id/#children","text":"","title":"Children"},{"location":"datamodel/docs/Person_id/#used-by","text":"Person","title":"Used by"},{"location":"datamodel/docs/Person_id/#other-properties","text":"Exact Mappings: sdo:identifier","title":"Other properties"},{"location":"datamodel/docs/Person_name/","text":"Slot: name full name URI: TEMP:Person_name Domain and Range Person \u2192 1..1 String Parents is_a: name Children Used by Person Other properties Exact Mappings: sdo:name","title":"Slot: name"},{"location":"datamodel/docs/Person_name/#slot-name","text":"full name URI: TEMP:Person_name","title":"Slot: name"},{"location":"datamodel/docs/Person_name/#domain-and-range","text":"Person \u2192 1..1 String","title":"Domain and Range"},{"location":"datamodel/docs/Person_name/#parents","text":"is_a: name","title":"Parents"},{"location":"datamodel/docs/Person_name/#children","text":"","title":"Children"},{"location":"datamodel/docs/Person_name/#used-by","text":"Person","title":"Used by"},{"location":"datamodel/docs/Person_name/#other-properties","text":"Exact Mappings: sdo:name","title":"Other properties"},{"location":"datamodel/docs/age/","text":"Slot: age URI: TEMP:age Domain and Range None \u2192 0..1 String Parents Children Person\u279eage Used by","title":"Slot: age"},{"location":"datamodel/docs/age/#slot-age","text":"URI: TEMP:age","title":"Slot: age"},{"location":"datamodel/docs/age/#domain-and-range","text":"None \u2192 0..1 String","title":"Domain and Range"},{"location":"datamodel/docs/age/#parents","text":"","title":"Parents"},{"location":"datamodel/docs/age/#children","text":"Person\u279eage","title":"Children"},{"location":"datamodel/docs/age/#used-by","text":"","title":"Used by"},{"location":"datamodel/docs/description/","text":"Slot: description a textual description URI: TEMP:description Domain and Range None \u2192 0..1 String Parents Children Used by Other properties Exact Mappings: sdo:description","title":"Slot: description"},{"location":"datamodel/docs/description/#slot-description","text":"a textual description URI: TEMP:description","title":"Slot: description"},{"location":"datamodel/docs/description/#domain-and-range","text":"None \u2192 0..1 String","title":"Domain and Range"},{"location":"datamodel/docs/description/#parents","text":"","title":"Parents"},{"location":"datamodel/docs/description/#children","text":"","title":"Children"},{"location":"datamodel/docs/description/#used-by","text":"","title":"Used by"},{"location":"datamodel/docs/description/#other-properties","text":"Exact Mappings: sdo:description","title":"Other properties"},{"location":"datamodel/docs/gender/","text":"Slot: gender URI: TEMP:gender Domain and Range None \u2192 0..1 String Parents Children Person\u279egender Used by","title":"Slot: gender"},{"location":"datamodel/docs/gender/#slot-gender","text":"URI: TEMP:gender","title":"Slot: gender"},{"location":"datamodel/docs/gender/#domain-and-range","text":"None \u2192 0..1 String","title":"Domain and Range"},{"location":"datamodel/docs/gender/#parents","text":"","title":"Parents"},{"location":"datamodel/docs/gender/#children","text":"Person\u279egender","title":"Children"},{"location":"datamodel/docs/gender/#used-by","text":"","title":"Used by"},{"location":"datamodel/docs/has_medical_history/","text":"Slot: has medical history URI: TEMP:has_medical_history Domain and Range None \u2192 0..1 String Parents Children Person\u279ehas medical history Used by","title":"Slot: has medical history"},{"location":"datamodel/docs/has_medical_history/#slot-has-medical-history","text":"URI: TEMP:has_medical_history","title":"Slot: has medical history"},{"location":"datamodel/docs/has_medical_history/#domain-and-range","text":"None \u2192 0..1 String","title":"Domain and Range"},{"location":"datamodel/docs/has_medical_history/#parents","text":"","title":"Parents"},{"location":"datamodel/docs/has_medical_history/#children","text":"Person\u279ehas medical history","title":"Children"},{"location":"datamodel/docs/has_medical_history/#used-by","text":"","title":"Used by"},{"location":"datamodel/docs/id/","text":"Slot: id any identifier URI: TEMP:id Domain and Range None \u2192 1..1 String Parents Children Person\u279eid Used by Other properties Exact Mappings: sdo:identifier","title":"Slot: id"},{"location":"datamodel/docs/id/#slot-id","text":"any identifier URI: TEMP:id","title":"Slot: id"},{"location":"datamodel/docs/id/#domain-and-range","text":"None \u2192 1..1 String","title":"Domain and Range"},{"location":"datamodel/docs/id/#parents","text":"","title":"Parents"},{"location":"datamodel/docs/id/#children","text":"Person\u279eid","title":"Children"},{"location":"datamodel/docs/id/#used-by","text":"","title":"Used by"},{"location":"datamodel/docs/id/#other-properties","text":"Exact Mappings: sdo:identifier","title":"Other properties"},{"location":"datamodel/docs/name/","text":"Slot: name URI: TEMP:name Domain and Range None \u2192 0..1 String Parents Children Organization\u279ename Person\u279ename Used by","title":"Slot: name"},{"location":"datamodel/docs/name/#slot-name","text":"URI: TEMP:name","title":"Slot: name"},{"location":"datamodel/docs/name/#domain-and-range","text":"None \u2192 0..1 String","title":"Domain and Range"},{"location":"datamodel/docs/name/#parents","text":"","title":"Parents"},{"location":"datamodel/docs/name/#children","text":"Organization\u279ename Person\u279ename","title":"Children"},{"location":"datamodel/docs/name/#used-by","text":"","title":"Used by"},{"location":"datamodel/docs/schema/","text":"TEMP schema Classes Event - grouping class for events MedicalEvent - a medical encounter Organization ForProfit NonProfit Person - a person,living or dead Mixins Slots age Person\u279eage - age in years description - a textual description gender Person\u279egender - age in years has medical history Person\u279ehas medical history - medical history id - any identifier Person\u279eid - identifier for a person name Organization\u279ename - full name Person\u279ename - full name Enums Subsets A B Types Built in Bool Decimal ElementIdentifier NCName NodeIdentifier URI URIorCURIE XSDDate XSDDateTime XSDTime float int str Defined Boolean ( Bool ) - A binary (true or false) value Date ( XSDDate ) - a date (year, month and day) in an idealized calendar Datetime ( XSDDateTime ) - The combination of a date and time Decimal ( Decimal ) - A real number with arbitrary precision that conforms to the xsd:decimal specification Double ( float ) - A real number that conforms to the xsd:double specification Float ( float ) - A real number that conforms to the xsd:float specification Integer ( int ) - An integer Ncname ( NCName ) - Prefix part of CURIE Nodeidentifier ( NodeIdentifier ) - A URI, CURIE or BNODE that represents a node in a model. Objectidentifier ( ElementIdentifier ) - A URI or CURIE that represents an object in the model. String ( str ) - A character string Time ( XSDTime ) - A time object represents a (local) time of day, independent of any particular day Uri ( URI ) - a complete URI Uriorcurie ( URIorCURIE ) - a URI or a CURIE","title":"TEMP schema"},{"location":"datamodel/docs/schema/#temp-schema","text":"","title":"TEMP schema"},{"location":"datamodel/docs/schema/#classes","text":"Event - grouping class for events MedicalEvent - a medical encounter Organization ForProfit NonProfit Person - a person,living or dead","title":"Classes"},{"location":"datamodel/docs/schema/#mixins","text":"","title":"Mixins"},{"location":"datamodel/docs/schema/#slots","text":"age Person\u279eage - age in years description - a textual description gender Person\u279egender - age in years has medical history Person\u279ehas medical history - medical history id - any identifier Person\u279eid - identifier for a person name Organization\u279ename - full name Person\u279ename - full name","title":"Slots"},{"location":"datamodel/docs/schema/#enums","text":"","title":"Enums"},{"location":"datamodel/docs/schema/#subsets","text":"A B","title":"Subsets"},{"location":"datamodel/docs/schema/#types","text":"","title":"Types"},{"location":"datamodel/docs/schema/#built-in","text":"Bool Decimal ElementIdentifier NCName NodeIdentifier URI URIorCURIE XSDDate XSDDateTime XSDTime float int str","title":"Built in"},{"location":"datamodel/docs/schema/#defined","text":"Boolean ( Bool ) - A binary (true or false) value Date ( XSDDate ) - a date (year, month and day) in an idealized calendar Datetime ( XSDDateTime ) - The combination of a date and time Decimal ( Decimal ) - A real number with arbitrary precision that conforms to the xsd:decimal specification Double ( float ) - A real number that conforms to the xsd:double specification Float ( float ) - A real number that conforms to the xsd:float specification Integer ( int ) - An integer Ncname ( NCName ) - Prefix part of CURIE Nodeidentifier ( NodeIdentifier ) - A URI, CURIE or BNODE that represents a node in a model. Objectidentifier ( ElementIdentifier ) - A URI or CURIE that represents an object in the model. String ( str ) - A character string Time ( XSDTime ) - A time object represents a (local) time of day, independent of any particular day Uri ( URI ) - a complete URI Uriorcurie ( URIorCURIE ) - a URI or a CURIE","title":"Defined"},{"location":"datamodel/types/Boolean/","text":"Type: boolean A binary (true or false) value URI: linkml:Boolean Root (builtin) type Bool Representation bool","title":"Type: boolean"},{"location":"datamodel/types/Boolean/#type-boolean","text":"A binary (true or false) value URI: linkml:Boolean Root (builtin) type Bool Representation bool","title":"Type: boolean"},{"location":"datamodel/types/Date/","text":"Type: date a date (year, month and day) in an idealized calendar URI: linkml:Date Root (builtin) type XSDDate Representation str","title":"Type: date"},{"location":"datamodel/types/Date/#type-date","text":"a date (year, month and day) in an idealized calendar URI: linkml:Date Root (builtin) type XSDDate Representation str","title":"Type: date"},{"location":"datamodel/types/Datetime/","text":"Type: datetime The combination of a date and time URI: linkml:Datetime Root (builtin) type XSDDateTime Representation str","title":"Type: datetime"},{"location":"datamodel/types/Datetime/#type-datetime","text":"The combination of a date and time URI: linkml:Datetime Root (builtin) type XSDDateTime Representation str","title":"Type: datetime"},{"location":"datamodel/types/Decimal/","text":"Type: decimal A real number with arbitrary precision that conforms to the xsd:decimal specification URI: linkml:Decimal Root (builtin) type Decimal","title":"Type: decimal"},{"location":"datamodel/types/Decimal/#type-decimal","text":"A real number with arbitrary precision that conforms to the xsd:decimal specification URI: linkml:Decimal Root (builtin) type Decimal","title":"Type: decimal"},{"location":"datamodel/types/Double/","text":"Type: double A real number that conforms to the xsd:double specification URI: linkml:Double Root (builtin) type float","title":"Type: double"},{"location":"datamodel/types/Double/#type-double","text":"A real number that conforms to the xsd:double specification URI: linkml:Double Root (builtin) type float","title":"Type: double"},{"location":"datamodel/types/ElementReference/","text":"Type: ElementReference A pointer to an element in a datamodel URI: schemasheets:ElementReference Root (builtin) type str","title":"Type: ElementReference"},{"location":"datamodel/types/ElementReference/#type-elementreference","text":"A pointer to an element in a datamodel URI: schemasheets:ElementReference Root (builtin) type str","title":"Type: ElementReference"},{"location":"datamodel/types/Float/","text":"Type: float A real number that conforms to the xsd:float specification URI: linkml:Float Root (builtin) type float","title":"Type: float"},{"location":"datamodel/types/Float/#type-float","text":"A real number that conforms to the xsd:float specification URI: linkml:Float Root (builtin) type float","title":"Type: float"},{"location":"datamodel/types/Integer/","text":"Type: integer An integer URI: linkml:Integer Root (builtin) type int","title":"Type: integer"},{"location":"datamodel/types/Integer/#type-integer","text":"An integer URI: linkml:Integer Root (builtin) type int","title":"Type: integer"},{"location":"datamodel/types/Ncname/","text":"Type: ncname Prefix part of CURIE URI: linkml:Ncname Root (builtin) type NCName Representation str","title":"Type: ncname"},{"location":"datamodel/types/Ncname/#type-ncname","text":"Prefix part of CURIE URI: linkml:Ncname Root (builtin) type NCName Representation str","title":"Type: ncname"},{"location":"datamodel/types/Nodeidentifier/","text":"Type: nodeidentifier A URI, CURIE or BNODE that represents a node in a model. URI: linkml:Nodeidentifier Root (builtin) type NodeIdentifier Representation str","title":"Type: nodeidentifier"},{"location":"datamodel/types/Nodeidentifier/#type-nodeidentifier","text":"A URI, CURIE or BNODE that represents a node in a model. URI: linkml:Nodeidentifier Root (builtin) type NodeIdentifier Representation str","title":"Type: nodeidentifier"},{"location":"datamodel/types/Objectidentifier/","text":"Type: objectidentifier A URI or CURIE that represents an object in the model. URI: linkml:Objectidentifier Root (builtin) type ElementIdentifier Representation str Other properties Comments: Used for inheritence and type checking","title":"Type: objectidentifier"},{"location":"datamodel/types/Objectidentifier/#type-objectidentifier","text":"A URI or CURIE that represents an object in the model. URI: linkml:Objectidentifier Root (builtin) type ElementIdentifier Representation str","title":"Type: objectidentifier"},{"location":"datamodel/types/Objectidentifier/#other-properties","text":"Comments: Used for inheritence and type checking","title":"Other properties"},{"location":"datamodel/types/String/","text":"Type: string A character string URI: linkml:String Root (builtin) type str","title":"Type: string"},{"location":"datamodel/types/String/#type-string","text":"A character string URI: linkml:String Root (builtin) type str","title":"Type: string"},{"location":"datamodel/types/Time/","text":"Type: time A time object represents a (local) time of day, independent of any particular day URI: linkml:Time Root (builtin) type XSDTime Representation str","title":"Type: time"},{"location":"datamodel/types/Time/#type-time","text":"A time object represents a (local) time of day, independent of any particular day URI: linkml:Time Root (builtin) type XSDTime Representation str","title":"Type: time"},{"location":"datamodel/types/Uri/","text":"Type: uri a complete URI URI: linkml:Uri Root (builtin) type URI Representation str","title":"Type: uri"},{"location":"datamodel/types/Uri/#type-uri","text":"a complete URI URI: linkml:Uri Root (builtin) type URI Representation str","title":"Type: uri"},{"location":"datamodel/types/Uriorcurie/","text":"Type: uriorcurie a URI or a CURIE URI: linkml:Uriorcurie Root (builtin) type URIorCURIE Representation str","title":"Type: uriorcurie"},{"location":"datamodel/types/Uriorcurie/#type-uriorcurie","text":"a URI or a CURIE URI: linkml:Uriorcurie Root (builtin) type URIorCURIE Representation str","title":"Type: uriorcurie"},{"location":"howto/data-dictionaries/","text":"Simple data dictionaries This framework allows you to represent complex relation-style schemas using spreadsheets/TSVs. But it also allows for representation of simple \"data dictionaries\" or \"minimal information lists\". These can be thought of as \"wide tables\", e.g. representing individual observations or observable units such as persons or samples. TODO","title":"Simple data dictionaries"},{"location":"howto/data-dictionaries/#simple-data-dictionaries","text":"This framework allows you to represent complex relation-style schemas using spreadsheets/TSVs. But it also allows for representation of simple \"data dictionaries\" or \"minimal information lists\". These can be thought of as \"wide tables\", e.g. representing individual observations or observable units such as persons or samples. TODO","title":"Simple data dictionaries"},{"location":"howto/excel/","text":"Working with Excel spreadsheets Currently no direct support, it is up to you to load/save as individual TSVs","title":"Working with Excel"},{"location":"howto/excel/#working-with-excel-spreadsheets","text":"Currently no direct support, it is up to you to load/save as individual TSVs","title":"Working with Excel spreadsheets"},{"location":"howto/google-sheets/","text":"Google sheets This tool takes as input a collection of sheets, which are stored as TSV files. You can make use of various ways of managing/organizing these: TSVs files maintained in GitHub Google sheets Excel spreadsheets SQLite databases Tips for each of these and for organizing your information are provided below Multiple sheets vs single sheets It is up to you whether you represent your schema as a single sheet or as multiple sheets However, if your schema includes a mixture of different element types, you may end up with a lot of null values if you have a single sheet. It can be more intuitive to \"normalize\" your schema description into different sheets: sheets for classes/slots sheets for enums sheets for types Currently schemasheets has no built in facilities for interacting directly with google sheets - it is up to you to both download and upload these TODO: scripts for merging/splitting sheets Manual upload/download Note that you can create a URL from a google sheet to the TSV download - TODO COGS We recommend the COGS framework for working with google sheets cogs A common pattern is a single sheet document for a schema, with different sheets/tabs for different parts of the schema Example TODO","title":"Working with Google Sheets"},{"location":"howto/google-sheets/#google-sheets","text":"This tool takes as input a collection of sheets, which are stored as TSV files. You can make use of various ways of managing/organizing these: TSVs files maintained in GitHub Google sheets Excel spreadsheets SQLite databases Tips for each of these and for organizing your information are provided below","title":"Google sheets"},{"location":"howto/google-sheets/#multiple-sheets-vs-single-sheets","text":"It is up to you whether you represent your schema as a single sheet or as multiple sheets However, if your schema includes a mixture of different element types, you may end up with a lot of null values if you have a single sheet. It can be more intuitive to \"normalize\" your schema description into different sheets: sheets for classes/slots sheets for enums sheets for types Currently schemasheets has no built in facilities for interacting directly with google sheets - it is up to you to both download and upload these TODO: scripts for merging/splitting sheets","title":"Multiple sheets vs single sheets"},{"location":"howto/google-sheets/#manual-uploaddownload","text":"Note that you can create a URL from a google sheet to the TSV download - TODO","title":"Manual upload/download"},{"location":"howto/google-sheets/#cogs","text":"We recommend the COGS framework for working with google sheets cogs A common pattern is a single sheet document for a schema, with different sheets/tabs for different parts of the schema","title":"COGS"},{"location":"howto/google-sheets/#example","text":"TODO","title":"Example"},{"location":"howto/sqlite/","text":"Working with SQLite TODO","title":"Working with SQLite"},{"location":"howto/sqlite/#working-with-sqlite","text":"TODO","title":"Working with SQLite"},{"location":"intro/basics/","text":"Basics Schemasheets allow you to write schemas to manage your data without writing any code. You keep the source for your schema as a spreadsheet (e.g. in google sheets), and convert to LinkML Example The following example shows a schema sheet for a schema that is focused around the concept of a Person. The rows in the sheet describe either classes or slots (fields) record field key multiplicity range desc schema.org > class slot identifier cardinality range description exact_mappings: {curie_prefix: sdo} - id yes 1 string any identifier identifier - description no 0..1 string a textual description description Person n/a n/a n/a a person,living or dead Person Person id yes 1 string identifier for a person identifier Person, Organization name no 1 string full name name Person age no 0..1 decimal age in years - Person gender no 0..1 decimal age in years - Person has medical history no 0..* MedicalEvent medical history - MedicalEvent n/a n/a n/a - - You can see this example as a google sheet: personinfo google sheet The sheet is structured as follows: Header Line The first line is a header line. You get to decide the column headers record field key multiplicity range desc schema.org Column Descriptors Subsequent lines starting with > are column descriptors these provide a way to interpret the columns descriptors can be drawn from the linkml vocabulary Schema Elements Remaining rows are elements of your schema Each element gets its own row A row can represent a class (record, table), field (column), enumeration, or other element types record field key multiplicity range desc schema.org > class slot identifier cardinality range description exact_mappings: {curie_prefix: sdo} Core Concepts The most basic schema concepts are classes and slots classes represent record types, similar to tables in a database or sheets in a spreadsheet slots represent fields, similar to columns in a database or spreadsheet These can be used in combination: If a class is provided, but a slot is not, then the row represents a class. If a slot is provided, but a class is not, then the row represents a slot (field) If both class and slot are provided, then the row represents the usage of a slot in the context of a class","title":"Basics"},{"location":"intro/basics/#basics","text":"Schemasheets allow you to write schemas to manage your data without writing any code. You keep the source for your schema as a spreadsheet (e.g. in google sheets), and convert to LinkML","title":"Basics"},{"location":"intro/basics/#example","text":"The following example shows a schema sheet for a schema that is focused around the concept of a Person. The rows in the sheet describe either classes or slots (fields) record field key multiplicity range desc schema.org > class slot identifier cardinality range description exact_mappings: {curie_prefix: sdo} - id yes 1 string any identifier identifier - description no 0..1 string a textual description description Person n/a n/a n/a a person,living or dead Person Person id yes 1 string identifier for a person identifier Person, Organization name no 1 string full name name Person age no 0..1 decimal age in years - Person gender no 0..1 decimal age in years - Person has medical history no 0..* MedicalEvent medical history - MedicalEvent n/a n/a n/a - - You can see this example as a google sheet: personinfo google sheet The sheet is structured as follows:","title":"Example"},{"location":"intro/basics/#header-line","text":"The first line is a header line. You get to decide the column headers record field key multiplicity range desc schema.org","title":"Header Line"},{"location":"intro/basics/#column-descriptors","text":"Subsequent lines starting with > are column descriptors these provide a way to interpret the columns descriptors can be drawn from the linkml vocabulary","title":"Column Descriptors"},{"location":"intro/basics/#schema-elements","text":"Remaining rows are elements of your schema Each element gets its own row A row can represent a class (record, table), field (column), enumeration, or other element types record field key multiplicity range desc schema.org > class slot identifier cardinality range description exact_mappings: {curie_prefix: sdo}","title":"Schema Elements"},{"location":"intro/basics/#core-concepts","text":"The most basic schema concepts are classes and slots classes represent record types, similar to tables in a database or sheets in a spreadsheet slots represent fields, similar to columns in a database or spreadsheet These can be used in combination: If a class is provided, but a slot is not, then the row represents a class. If a slot is provided, but a class is not, then the row represents a slot (field) If both class and slot are provided, then the row represents the usage of a slot in the context of a class","title":"Core Concepts"},{"location":"intro/cardinality/","text":"Specifying cardinality About Cardinality refers to how many values a particular field is required or allowed to have How it works See configschema.yaml for all possible vocabularies, these include: UML strings, e.g. '0..1' text strings matching the cardinality vocabulary, e.g. 'zero to one' codes used in cardinality vocabulary, e.g. O, M, ... The vocabulary maps to underlying LinkML primitives: required multivalued recommended Cardinality Vocabulary Cardinality vocabulary yaml Examples TODO","title":"Cardinality"},{"location":"intro/cardinality/#specifying-cardinality","text":"","title":"Specifying cardinality"},{"location":"intro/cardinality/#about","text":"Cardinality refers to how many values a particular field is required or allowed to have","title":"About"},{"location":"intro/cardinality/#how-it-works","text":"See configschema.yaml for all possible vocabularies, these include: UML strings, e.g. '0..1' text strings matching the cardinality vocabulary, e.g. 'zero to one' codes used in cardinality vocabulary, e.g. O, M, ... The vocabulary maps to underlying LinkML primitives: required multivalued recommended","title":"How it works"},{"location":"intro/cardinality/#cardinality-vocabulary","text":"Cardinality vocabulary yaml","title":"Cardinality Vocabulary"},{"location":"intro/cardinality/#examples","text":"TODO","title":"Examples"},{"location":"intro/converting/","text":"Generating schemas Although you can use schemasheets without writing any code, some technical expertise is still required to run scripts to generate schema artefacts from sheets, and to use these. Generating a Project Assuming your schema is arranged as a set of sheets (TSV files) in the src folder: sheets2project -d . src/*.tsv This will generate individual folders for jsonschema, shacl, ... as well as a website that can be easily hosted on github. Generating a LinkML schema To create only LinkML yaml: sheets2linkml -o my.yaml src/*.tsv","title":"Converting"},{"location":"intro/converting/#generating-schemas","text":"Although you can use schemasheets without writing any code, some technical expertise is still required to run scripts to generate schema artefacts from sheets, and to use these.","title":"Generating schemas"},{"location":"intro/converting/#generating-a-project","text":"Assuming your schema is arranged as a set of sheets (TSV files) in the src folder: sheets2project -d . src/*.tsv This will generate individual folders for jsonschema, shacl, ... as well as a website that can be easily hosted on github.","title":"Generating a Project"},{"location":"intro/converting/#generating-a-linkml-schema","text":"To create only LinkML yaml: sheets2linkml -o my.yaml src/*.tsv","title":"Generating a LinkML schema"},{"location":"intro/enums/","text":"Enums About Enumerations can be thought of as \"dropdowns\" or picklists in data entry forms. Minimally, the enum is a predefined set of strings. These strings can optionally be provided with more metadata, such as descriptions or assignment of controlled vocabulary/ontology terms How it works Two descriptors are provided for enumerations: enum permissible_value These can be used in combination: If enum is provided, and permissible_value is not, then the row represents an enumeration If both enum and permissible_value are provided, the row represents a particular enum value Example The following example includes two enums: ValueSet Value Mapping Desc > enum permissible_value meaning description FamilialRelationshipType - - familial relationships FamilialRelationshipType SIBLING_OF famrel:01 share the same parent FamilialRelationshipType PARENT_OF famrel:02 biological parent FamilialRelationshipType CHILD_OF famrel:03 inverse of parent GenderType - - gender GenderType nonbinary man GSSO:009254 - GenderType nonbinary woman GSSO:009253 - ... ... ... - enums google sheet All other descriptors are optional, but we recommend you provide descriptions of both the enumeration and the meaning descriptor which maps the value to a vocabulary or ontology term. More info For more on enumerations, see the linkml tutorial","title":"Enums"},{"location":"intro/enums/#enums","text":"","title":"Enums"},{"location":"intro/enums/#about","text":"Enumerations can be thought of as \"dropdowns\" or picklists in data entry forms. Minimally, the enum is a predefined set of strings. These strings can optionally be provided with more metadata, such as descriptions or assignment of controlled vocabulary/ontology terms","title":"About"},{"location":"intro/enums/#how-it-works","text":"Two descriptors are provided for enumerations: enum permissible_value These can be used in combination: If enum is provided, and permissible_value is not, then the row represents an enumeration If both enum and permissible_value are provided, the row represents a particular enum value","title":"How it works"},{"location":"intro/enums/#example","text":"The following example includes two enums: ValueSet Value Mapping Desc > enum permissible_value meaning description FamilialRelationshipType - - familial relationships FamilialRelationshipType SIBLING_OF famrel:01 share the same parent FamilialRelationshipType PARENT_OF famrel:02 biological parent FamilialRelationshipType CHILD_OF famrel:03 inverse of parent GenderType - - gender GenderType nonbinary man GSSO:009254 - GenderType nonbinary woman GSSO:009253 - ... ... ... - enums google sheet All other descriptors are optional, but we recommend you provide descriptions of both the enumeration and the meaning descriptor which maps the value to a vocabulary or ontology term.","title":"Example"},{"location":"intro/enums/#more-info","text":"For more on enumerations, see the linkml tutorial","title":"More info"},{"location":"intro/export/","text":"Exporting a schema to schemasheets Use Case Sometimes you might want to export from an existing LinkML schema to schemasheets - for example to migrate the source of some or part of a schema to sheet-based editing. The sheets2linkml command will convert schemasheet(s) to a LinkML schema The reverse operation linkml2sheets will convert a LinkML schema to schemasheets Status THIS COMMAND IS ONLY PARTIALLY IMPLEMENTED -- not all parts of the specification are considered. However, you may still find this useful for \"bootstrapping\" schema sheets Usage Type linkml2sheets --help to get complete help Broadly there are two usage scenarios: when you have a single sheet when your schema is mapped to multiple sheets (e.g. enums and slots in different sheets) In both cases you need two inputs A linkml schema, specified in yaml One or more schemasheets that serve as the specification these do not need to have any data they do need the columns used and column descriptors Single-sheet usage Here you pass a single TSV specification on the command line You can use the --output ( -o ) option to write output to a single sheet file. Or omit this to write on stdout. Multi-sheet usage Here you multiple TSV specifications on the command line You must use the --directory ( -d ) option to specify which directory the files are written to. The filenames will be the same. So for example, if you had a folder: sheets/ enums.tsv slots.tsv where: each tsv contains minimally the column specifications, you pass in sheets/*tsv as input you pass --directory output Then you will generate a folder: output/ enums.tsv slots.tsv the headers will be the same as the TSVs in the input, but it will include \"data\" rows, where each row is a matching schema element the input and output directory can be identical, but you will need to pass in --overwrite to explicitly overwrite, this guards against accidental overwrites. Converting between two different schemasheet specs schemasheets allows custom sheet formats that map to the LinkML standard. you can use the combination of sheets2linkml and linkml2sheets to convert betweeen two sheet specifications. For example, let's say for schema1.tsv, you use a spreadsheet with the following headers: record: > class field: > slot cardinality: > cardinality info: > description and for schema2.tsv you have: table: > class attribute: > slot required: > required multivalued: > multivalued description: > description (here each list element is a column, and the part after the > is the 2nd row) If you do: sheets2linkml schema1.tsv > schema1.yaml linkml2sheets -s schema1.yaml schema2.tsv > schema2_full.tsv then this will effectively map schema1.tsv onto the format for schema2.tsv. And you can swap the arguments to go in the reverse direction.","title":"Exporting to schemasheets"},{"location":"intro/export/#exporting-a-schema-to-schemasheets","text":"","title":"Exporting a schema to schemasheets"},{"location":"intro/export/#use-case","text":"Sometimes you might want to export from an existing LinkML schema to schemasheets - for example to migrate the source of some or part of a schema to sheet-based editing. The sheets2linkml command will convert schemasheet(s) to a LinkML schema The reverse operation linkml2sheets will convert a LinkML schema to schemasheets","title":"Use Case"},{"location":"intro/export/#status","text":"THIS COMMAND IS ONLY PARTIALLY IMPLEMENTED -- not all parts of the specification are considered. However, you may still find this useful for \"bootstrapping\" schema sheets","title":"Status"},{"location":"intro/export/#usage","text":"Type linkml2sheets --help to get complete help Broadly there are two usage scenarios: when you have a single sheet when your schema is mapped to multiple sheets (e.g. enums and slots in different sheets) In both cases you need two inputs A linkml schema, specified in yaml One or more schemasheets that serve as the specification these do not need to have any data they do need the columns used and column descriptors","title":"Usage"},{"location":"intro/export/#single-sheet-usage","text":"Here you pass a single TSV specification on the command line You can use the --output ( -o ) option to write output to a single sheet file. Or omit this to write on stdout.","title":"Single-sheet usage"},{"location":"intro/export/#multi-sheet-usage","text":"Here you multiple TSV specifications on the command line You must use the --directory ( -d ) option to specify which directory the files are written to. The filenames will be the same. So for example, if you had a folder: sheets/ enums.tsv slots.tsv where: each tsv contains minimally the column specifications, you pass in sheets/*tsv as input you pass --directory output Then you will generate a folder: output/ enums.tsv slots.tsv the headers will be the same as the TSVs in the input, but it will include \"data\" rows, where each row is a matching schema element the input and output directory can be identical, but you will need to pass in --overwrite to explicitly overwrite, this guards against accidental overwrites.","title":"Multi-sheet usage"},{"location":"intro/export/#converting-between-two-different-schemasheet-specs","text":"schemasheets allows custom sheet formats that map to the LinkML standard. you can use the combination of sheets2linkml and linkml2sheets to convert betweeen two sheet specifications. For example, let's say for schema1.tsv, you use a spreadsheet with the following headers: record: > class field: > slot cardinality: > cardinality info: > description and for schema2.tsv you have: table: > class attribute: > slot required: > required multivalued: > multivalued description: > description (here each list element is a column, and the part after the > is the 2nd row) If you do: sheets2linkml schema1.tsv > schema1.yaml linkml2sheets -s schema1.yaml schema2.tsv > schema2_full.tsv then this will effectively map schema1.tsv onto the format for schema2.tsv. And you can swap the arguments to go in the reverse direction.","title":"Converting between two different schemasheet specs"},{"location":"intro/grids/","text":"Overriding fields Use Case Previously we saw example of how to define fields (slots). The characteristics of these fields remained the same even if they were used with different classes If you have a large number of fields/columns, with varying applicability/cardinality across different classes, it can be convenient to specify this as a grid. Example An example is a minimal information standard that includes different packages or checklists, e.g. MIxS. Here we may want a slot such as \"soil sample depth\" to be mandatory for soil samples, optional for other kinds of samples. For example: term title desc mi_patient mi_mod mi_terrestrial mi_marine mi_extraterrestrial > slot title description cardinality cardinality cardinality cardinality cardinality > applies_to_class: MI patient applies_to_class: MI model organism applies_to_class: MI terrestrial sample applies_to_class: MI marine sample applies_to_class: MI extraterrestrial sample id unique identifier a unique id M M M M M alt_ids other identifiers any other identifiers O O O O O body_site body site location where sample is taken from M R - - - disease disease status disease the patient had M O - - - age age age M R - - - depth depth depth in ground or water - - R R R alt altitude height above sea level R R R salinity salinity salinity R R R porosity porosity porosity location location location on earth astronomical_body astronomical body planet or other astronomical object where sample was collected M data dictionary google sheet Here the applies_to_class descriptor indicates that the column value for the slot indicated in the row is interpreted as slot usage for that class. More information See slot usage","title":"Grids"},{"location":"intro/grids/#overriding-fields","text":"","title":"Overriding fields"},{"location":"intro/grids/#use-case","text":"Previously we saw example of how to define fields (slots). The characteristics of these fields remained the same even if they were used with different classes If you have a large number of fields/columns, with varying applicability/cardinality across different classes, it can be convenient to specify this as a grid.","title":"Use Case"},{"location":"intro/grids/#example","text":"An example is a minimal information standard that includes different packages or checklists, e.g. MIxS. Here we may want a slot such as \"soil sample depth\" to be mandatory for soil samples, optional for other kinds of samples. For example: term title desc mi_patient mi_mod mi_terrestrial mi_marine mi_extraterrestrial > slot title description cardinality cardinality cardinality cardinality cardinality > applies_to_class: MI patient applies_to_class: MI model organism applies_to_class: MI terrestrial sample applies_to_class: MI marine sample applies_to_class: MI extraterrestrial sample id unique identifier a unique id M M M M M alt_ids other identifiers any other identifiers O O O O O body_site body site location where sample is taken from M R - - - disease disease status disease the patient had M O - - - age age age M R - - - depth depth depth in ground or water - - R R R alt altitude height above sea level R R R salinity salinity salinity R R R porosity porosity porosity location location location on earth astronomical_body astronomical body planet or other astronomical object where sample was collected M data dictionary google sheet Here the applies_to_class descriptor indicates that the column value for the slot indicated in the row is interpreted as slot usage for that class.","title":"Example"},{"location":"intro/grids/#more-information","text":"See slot usage","title":"More information"},{"location":"intro/mixed-sheets/","text":"Mixed sheets In all of the examples above, distinct descriptors are used for class names, slot names, type names, enum names, etc An alternative pattern is to mix element types in a single sheet, indicate the name of the element using name and the type using metatype . For example: type item applies to key multiplicity range parents desc schema.org wikidata belongs status notes > metatype name class identifier cardinality range is_a description exact_mappings: {curie_prefix: sdo} exact_mappings: {curie_prefix: wikidata} in_subset status ignore > vmap: {C: class, F: slot} > curie_prefix: wikidata vmap: {T: testing, R: release} F id yes 1 string any identifier identifier F name Person, Organization no 1 string full name name F description no 0..1 string a textual description description F age Person no 0..1 decimal age in years F gender Person no 0..1 decimal age in years F has medical history Person no 0..* MedicalEvent medical history T C Person a person,living or dead Person Q215627 R C Event grouping class for events Q1656682 a R C MedicalEvent Event a medical encounter b T C ForProfit Organization C NonProfit Organization Q163740 foo personinfo with tyoes","title":"Mixed sheets"},{"location":"intro/mixed-sheets/#mixed-sheets","text":"In all of the examples above, distinct descriptors are used for class names, slot names, type names, enum names, etc An alternative pattern is to mix element types in a single sheet, indicate the name of the element using name and the type using metatype . For example: type item applies to key multiplicity range parents desc schema.org wikidata belongs status notes > metatype name class identifier cardinality range is_a description exact_mappings: {curie_prefix: sdo} exact_mappings: {curie_prefix: wikidata} in_subset status ignore > vmap: {C: class, F: slot} > curie_prefix: wikidata vmap: {T: testing, R: release} F id yes 1 string any identifier identifier F name Person, Organization no 1 string full name name F description no 0..1 string a textual description description F age Person no 0..1 decimal age in years F gender Person no 0..1 decimal age in years F has medical history Person no 0..* MedicalEvent medical history T C Person a person,living or dead Person Q215627 R C Event grouping class for events Q1656682 a R C MedicalEvent Event a medical encounter b T C ForProfit Organization C NonProfit Organization Q163740 foo personinfo with tyoes","title":"Mixed sheets"},{"location":"intro/prefixes/","text":"Prefixes If you specify a column descriptor of prefix , then rows with that column populated will represent prefixes. The prefix expansion is specified using prefix_reference Example prefix URI > prefix prefix_reference sdo http://schema.org/ personinfo https://w3id.org/linkml/examples/personinfo/ famrel https://example.org/FamilialRelations# GSSO http://purl.obolibrary.org/obo/GSSO_ Recommendations We recommend you specify prefixes in their own sheet. Automatic prefixes If prefixes are not provided, and you do not specify --no-repair then prefixes will be inferred using bioregistry","title":"Prefixes"},{"location":"intro/prefixes/#prefixes","text":"If you specify a column descriptor of prefix , then rows with that column populated will represent prefixes. The prefix expansion is specified using prefix_reference","title":"Prefixes"},{"location":"intro/prefixes/#example","text":"prefix URI > prefix prefix_reference sdo http://schema.org/ personinfo https://w3id.org/linkml/examples/personinfo/ famrel https://example.org/FamilialRelations# GSSO http://purl.obolibrary.org/obo/GSSO_","title":"Example"},{"location":"intro/prefixes/#recommendations","text":"We recommend you specify prefixes in their own sheet.","title":"Recommendations"},{"location":"intro/prefixes/#automatic-prefixes","text":"If prefixes are not provided, and you do not specify --no-repair then prefixes will be inferred using bioregistry","title":"Automatic prefixes"},{"location":"intro/schema-metadata/","text":"Schema-level metadata If you specify a column descriptor of schema , then rows with that column populated will represent schemas. Example: Schema uri Desc Schema Prefix > schema id description default_prefix PersonInfo https://w3id.org/linkml/examples/personinfo Information about people, based on schema.org personinfo The list of potential descriptors for a schema can be found by consulting SchemaDefinition in the LinkML metamodel. Both id and name are required, these will be auto-filled if you don't fill this in. Populating the fields description and license is strongly encouraged. Currently multiple schemas are not supported, we recommend providing a single-row sheet for schema metadata","title":"Schema-level metadata"},{"location":"intro/schema-metadata/#schema-level-metadata","text":"If you specify a column descriptor of schema , then rows with that column populated will represent schemas. Example: Schema uri Desc Schema Prefix > schema id description default_prefix PersonInfo https://w3id.org/linkml/examples/personinfo Information about people, based on schema.org personinfo The list of potential descriptors for a schema can be found by consulting SchemaDefinition in the LinkML metamodel. Both id and name are required, these will be auto-filled if you don't fill this in. Populating the fields description and license is strongly encouraged. Currently multiple schemas are not supported, we recommend providing a single-row sheet for schema metadata","title":"Schema-level metadata"}]}